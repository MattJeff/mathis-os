; ════════════════════════════════════════════════════════════════════════════════
; MATHIS COMPILER v2.0 - Enhanced Version
; Reads .mhs file, tokenizes, parses functions, generates real .masm
; ════════════════════════════════════════════════════════════════════════════════

.module "mathisc_v2"
.version "2.0.0"

.constants:
    ; Banner (0-4)
    0: str "╔══════════════════════════════════════════════════════════════╗\n"
    1: str "║       MATHIS COMPILER v2.0 - Enhanced Edition               ║\n"
    2: str "║         Written in MathisASM (bootstrapped)                 ║\n"
    3: str "╚══════════════════════════════════════════════════════════════╝\n"
    4: str "\n"

    ; Messages (5-15)
    5: str "Input: "
    6: str "\n[1/4] Reading file...\n"
    7: str "[2/4] Tokenizing...\n"
    8: str "[3/4] Parsing...\n"
    9: str "[4/4] Generating code...\n"
    10: str "\n✓ Compilation successful!\n"
    11: str "Output: "
    12: str " bytes read\n"
    13: str " tokens\n"
    14: str " functions found\n"
    15: str "  Found function: "

    ; Output generation (16-34)
    16: str "; Generated by MATHIS Compiler v2.0\n"
    17: str "; Source: "
    18: str "\n\n"
    19: str ".module \""
    20: str "\"\n"
    21: str ".version \"1.0.0\"\n\n"
    22: str ".func "
    23: str "\n    .arity "
    24: str "\n    .locals 10\n"
    25: str "    .ai_block \""
    26: str "\"\n"
    27: str "    .ai_intent \"Auto-generated\"\n\n"
    28: str "    ; Auto-generated body\n"
    29: str "    CONST_I64 0\n"
    30: str "    RET\n"
    31: str ".end\n\n"
    32: str "0"
    33: str "main"
    34: str "compiled"

    ; File paths (35-36)
    35: str "/Users/mathishiguinen/Desktop/Higuinen/mathis-os/mathisc/mathisc.mhs"
    36: str "mathisc/mathisc_compiled.masm"

    ; Keywords (37-41)
    37: str "func"
    38: str "let"
    39: str "return"
    40: str "if"
    41: str "else"

.func main
    .arity 0
    .locals 15
    .ai_block "compiler_main"
    .ai_intent "Compile a MATHIS file with function extraction"

    ; Locals:
    ; 0 = source code
    ; 1 = source length
    ; 2 = pos
    ; 3 = output string
    ; 4 = temp char
    ; 5 = function count
    ; 6 = token count
    ; 7 = temp
    ; 8 = function name start
    ; 9 = function name end

    ; ═══════════════════════════════════════════════════════════════
    ; Print banner
    ; ═══════════════════════════════════════════════════════════════
    CONST 0
    SYSCALL 0x0010
    POP
    CONST 1
    SYSCALL 0x0010
    POP
    CONST 2
    SYSCALL 0x0010
    POP
    CONST 3
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; Print input file
    CONST 5
    SYSCALL 0x0010
    POP
    CONST 35         ; input path
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 1: Read file
    ; ═══════════════════════════════════════════════════════════════
    CONST 6
    SYSCALL 0x0010
    POP

    CONST 35         ; input path
    SYSCALL 0x0015
    SET_LOCAL 0

    GET_LOCAL 0
    LEN
    SET_LOCAL 1

    GET_LOCAL 1
    TRACE
    CONST 12
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 2: Tokenize and count
    ; ═══════════════════════════════════════════════════════════════
    CONST 7
    SYSCALL 0x0010
    POP

    CONST_I64 0
    SET_LOCAL 2      ; pos = 0

    CONST_I64 0
    SET_LOCAL 5      ; function count = 0

    CONST_I64 0
    SET_LOCAL 6      ; token count = 0

    ; Initialize output with header
    CONST 16         ; "; Generated by..."
    CONST 17         ; "; Source: "
    ADD
    CONST 35         ; input path
    ADD
    CONST 18         ; "\n\n"
    ADD
    CONST 19         ; ".module \""
    ADD
    CONST 34         ; "compiled"
    ADD
    CONST 20         ; "\"\n"
    ADD
    CONST 21         ; ".version..."
    ADD
    SET_LOCAL 3      ; output = header + module

.scan_loop:
    GET_LOCAL 2
    GET_LOCAL 1
    LT
    JUMP_IF_FALSE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Check for 'f' (maybe 'func')
    GET_LOCAL 4
    CONST_I64 102
    EQ
    JUMP_IF_TRUE .maybe_func

    ; Check for @ (annotation)
    GET_LOCAL 4
    CONST_I64 64
    EQ
    JUMP_IF_TRUE .found_annotation

    ; Check for " (string)
    GET_LOCAL 4
    CONST_I64 34
    EQ
    JUMP_IF_TRUE .skip_string

    JUMP .next_char

.found_annotation:
    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6
    JUMP .skip_to_paren_or_space

.skip_to_paren_or_space:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 40
    EQ
    JUMP_IF_TRUE .next_char

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .next_char

    GET_LOCAL 4
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .next_char

    JUMP .skip_to_paren_or_space

.maybe_func:
    ; Check if we have "func" keyword
    GET_LOCAL 2
    CONST_I64 3
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_char

    ; Check 'u'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 117
    NE
    JUMP_IF_TRUE .next_char

    ; Check 'n'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 110
    NE
    JUMP_IF_TRUE .next_char

    ; Check 'c'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 3
    ADD
    INDEX
    CONST_I64 99
    NE
    JUMP_IF_TRUE .next_char

    ; Found 'func'!
    GET_LOCAL 5
    CONST_I64 1
    ADD
    SET_LOCAL 5

    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6

    ; Skip 'func' and space
    GET_LOCAL 2
    CONST_I64 5
    ADD
    SET_LOCAL 2

    ; Record function name start
    GET_LOCAL 2
    SET_LOCAL 8

    ; Find function name end (at '(' or space)
.find_func_name_end:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 40
    EQ
    JUMP_IF_TRUE .got_func_name

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .got_func_name

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_func_name_end

.got_func_name:
    GET_LOCAL 2
    SET_LOCAL 9

    ; Print found function
    CONST 15
    SYSCALL 0x0010
    POP

    ; Extract and print function name using substring
    ; For now, just print a placeholder
    CONST 33         ; "main"
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; Add function to output
    GET_LOCAL 3
    CONST 22         ; ".func "
    ADD
    CONST 33         ; "main"
    ADD
    CONST 23         ; "\n    .arity "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 24         ; "\n    .locals 10\n"
    ADD
    CONST 25         ; "    .ai_block \""
    ADD
    CONST 33         ; "main"
    ADD
    CONST 26         ; "\"\n"
    ADD
    CONST 27         ; "    .ai_intent..."
    ADD
    CONST 28         ; "    ; Auto-generated..."
    ADD
    CONST 29         ; "    CONST_I64 0\n"
    ADD
    CONST 30         ; "    RET\n"
    ADD
    CONST 31         ; ".end\n\n"
    ADD
    SET_LOCAL 3

    JUMP .skip_to_brace

.skip_to_brace:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .skip_brace_content

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_brace

.skip_brace_content:
    ; Skip until matching }
    CONST_I64 1
    SET_LOCAL 7      ; brace count = 1

.skip_braces:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .inc_brace

    GET_LOCAL 4
    CONST_I64 125
    EQ
    JUMP_IF_TRUE .dec_brace

    JUMP .skip_braces

.inc_brace:
    GET_LOCAL 7
    CONST_I64 1
    ADD
    SET_LOCAL 7
    JUMP .skip_braces

.dec_brace:
    GET_LOCAL 7
    CONST_I64 1
    SUB
    SET_LOCAL 7

    GET_LOCAL 7
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .next_char

    JUMP .skip_braces

.skip_string:
    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6

.skip_string_content:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 34
    EQ
    JUMP_IF_TRUE .next_char

    JUMP .skip_string_content

.next_char:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .scan_loop

.scan_done:
    ; Print token count
    GET_LOCAL 6
    TRACE
    CONST 13
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 3: Parsing done (we extracted functions above)
    ; ═══════════════════════════════════════════════════════════════
    CONST 8
    SYSCALL 0x0010
    POP

    GET_LOCAL 5
    TRACE
    CONST 14
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 4: Generate output (already built in local 3)
    ; ═══════════════════════════════════════════════════════════════
    CONST 9
    SYSCALL 0x0010
    POP

    ; Write output file
    CONST 36         ; output path
    GET_LOCAL 3
    SYSCALL 0x0016
    POP

    ; Print success
    CONST 10
    SYSCALL 0x0010
    POP

    CONST 11
    SYSCALL 0x0010
    POP

    CONST 36         ; output path
    SYSCALL 0x0010
    POP

    CONST_I64 0
    RET
.end
