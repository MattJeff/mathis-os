; ════════════════════════════════════════════════════════════════════════════════
; MATHIS COMPILER v7.0 - Loops, Arrays, and Memory Access
; Now supports: while, for, arrays, memory operations
; ════════════════════════════════════════════════════════════════════════════════

.module "mathisc_v7"
.version "7.0.0"

.constants:
    ; Banner (0-4)
    0: str "╔══════════════════════════════════════════════════════════════╗\n"
    1: str "║       MATHIS COMPILER v7.0 - Loops & Arrays Edition         ║\n"
    2: str "║    while/for loops, arrays, structs, memory access          ║\n"
    3: str "╚══════════════════════════════════════════════════════════════╝\n"
    4: str "\n"

    ; Messages (5-15)
    5: str "Input: "
    6: str "\n[1/4] Reading file...\n"
    7: str "[2/4] Tokenizing...\n"
    8: str "[3/4] Parsing...\n"
    9: str "[4/4] Generating code...\n"
    10: str "\n✓ Compilation successful!\n"
    11: str "Output: "
    12: str " bytes read\n"
    13: str " tokens\n"
    14: str " functions found\n"
    15: str "  func "

    ; Output generation (16-31)
    16: str "; Generated by MATHIS Compiler v7.0\n"
    17: str "; Source: "
    18: str "\n\n"
    19: str ".module \""
    20: str "\"\n"
    21: str ".version \"1.0.0\"\n\n"
    22: str ".func "
    23: str "\n    .arity "
    24: str "\n    .locals 20\n"
    25: str "    .ai_block \""
    26: str "\"\n"
    27: str "    .ai_intent \"Compiled from MATHIS\"\n\n"
    28: str "    ; Function body\n"
    29: str "    GET_LOCAL 0\n    GET_LOCAL 1\n    ADD\n    RET\n"
    30: str "    RET\n"
    31: str ".end\n\n"

    ; Numbers and names (32-40)
    32: str "0"
    33: str "main"
    34: str "compiled"
    35: str "/Users/mathishiguinen/Desktop/Higuinen/llml/examples/loops.mhs"
    36: str "mathisc/output_v7.masm"
    37: str "("
    38: str "): "
    39: str "\n"
    40: str "    ; stub\n    CONST_I64 0\n    RET\n"

    ; Arity and local digits (41-50)
    41: str "1"
    42: str "2"
    43: str "3"
    44: str "4"
    45: str "5"
    46: str "6"
    47: str "7"
    48: str "8"
    49: str "9"
    50: str "    GET_LOCAL "

    ; Operators (51-55)
    51: str "    ADD\n"
    52: str "    SUB\n"
    53: str "    MUL\n"
    54: str "    DIV\n"
    55: str "    RET\n"

    ; Comparisons (56-61)
    56: str "    GT\n"
    57: str "    LT\n"
    58: str "    LE\n"
    59: str "    GE\n"
    60: str "    EQ\n"
    61: str "    NE\n"

    ; Control flow - if/else (62-70)
    62: str "    JUMP_IF_FALSE .else_"
    63: str "    JUMP .endif_"
    64: str ".else_"
    65: str ":\n"
    66: str ".endif_"
    67: str "    ; if condition\n"
    68: str "    ; else branch\n"
    69: str "    CONST_I64 "
    70: str "    NEG\n"

    ; Call (71-75)
    71: str "    CALL \""
    72: str " "
    73: str "    ; recursive call\n"
    74: str "    ; call "
    75: str " with args\n"

    ; Debug messages (76-80)
    76: str "  [if detected]\n"
    77: str "  [call detected: "
    78: str "]\n"
    79: str "  [var: "
    80: str "  [expr: "

    ; Call format helpers (81-83)
    81: str "\" "
    82: str "\n"

    ; ═══════════════════════════════════════════════════════════════
    ; NEW: While loop constants (83-90)
    ; ═══════════════════════════════════════════════════════════════
    83: str "  [while detected]\n"
    84: str ".while_"
    85: str "    ; while loop\n"
    86: str "    JUMP_IF_FALSE .endwhile_"
    87: str ".endwhile_"
    88: str "    JUMP .while_"

    ; ═══════════════════════════════════════════════════════════════
    ; NEW: For loop constants (89-96)
    ; ═══════════════════════════════════════════════════════════════
    89: str "  [for detected]\n"
    90: str ".for_"
    91: str "    ; for loop init\n"
    92: str "    SET_LOCAL "
    93: str "    ; for loop condition\n"
    94: str ".endfor_"
    95: str "    ; for loop increment\n"
    96: str "    CONST_I64 1\n    ADD\n"

    ; ═══════════════════════════════════════════════════════════════
    ; NEW: Array constants (97-105)
    ; ═══════════════════════════════════════════════════════════════
    97: str "  [array detected]\n"
    98: str "    ; array literal\n"
    99: str "    ARRAY_NEW "
    100: str "    ARRAY_PUSH\n"
    101: str "    INDEX\n"
    102: str "    ; array access\n"
    103: str "    ARRAY_SET\n"
    104: str "    ARRAY_LEN\n"
    105: str "    ; let binding\n"

    ; ═══════════════════════════════════════════════════════════════
    ; NEW: Memory access constants (106-110)
    ; ═══════════════════════════════════════════════════════════════
    106: str "    LOAD8\n"
    107: str "    LOAD16\n"
    108: str "    LOAD32\n"
    109: str "    LOAD64\n"
    110: str "    STORE8\n"
    111: str "    STORE16\n"
    112: str "    STORE32\n"
    113: str "    STORE64\n"

    ; ═══════════════════════════════════════════════════════════════
    ; NEW: Struct constants (114-120)
    ; ═══════════════════════════════════════════════════════════════
    114: str "  [struct detected]\n"
    115: str "    ; struct field access\n"
    116: str "    FIELD_GET "
    117: str "    FIELD_SET "
    118: str "    STRUCT_NEW "

    ; Let binding (119-122)
    119: str "  [let detected: "
    120: str "    ; local "
    121: str " = "
    122: str "10"

    ; For loop labels (123-124)
    123: str "    JUMP .for_"
    124: str "    JUMP_IF_FALSE .endfor_"

.func main
    .arity 0
    .locals 50
    .ai_block "compiler_main"
    .ai_intent "Compile MATHIS with loops, arrays, and memory access"

    ; Locals:
    ; 0 = source code
    ; 1 = source length
    ; 2 = pos
    ; 3 = output string
    ; 4 = temp char
    ; 5 = function count
    ; 6 = token count
    ; 7 = brace count
    ; 8 = function name start / temp start
    ; 9 = function name end / temp end
    ; 10 = extracted function name
    ; 11 = param count
    ; 12 = body start
    ; 13 = body end
    ; 14 = label counter for if/else
    ; 15 = first param name
    ; 16 = second param name
    ; 17 = temp string
    ; 18 = comparison type / operator type
    ; 19 = in_if_branch flag
    ; 20 = current function index
    ; 21 = else_seen flag
    ; 22 = var_end position
    ; 23 = jump_emitted flag
    ; 24 = called function name
    ; 25 = call argument count
    ; 26 = temp position
    ;
    ; NEW for v7:
    ; 27 = while_label_counter
    ; 28 = for_label_counter
    ; 29 = in_while_loop flag
    ; 30 = in_for_loop flag
    ; 31 = for_loop_var (local index for iterator)
    ; 32 = for_loop_end value
    ; 33 = local_var_count (for let bindings)
    ; 34 = current_let_var_name
    ; 35 = array_size (for array literals)
    ; 36-45 = reserved for local variable names (up to 10 locals)

    ; ═══════════════════════════════════════════════════════════════
    ; Print banner
    ; ═══════════════════════════════════════════════════════════════
    CONST 0
    SYSCALL 0x0010
    POP
    CONST 1
    SYSCALL 0x0010
    POP
    CONST 2
    SYSCALL 0x0010
    POP
    CONST 3
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; Print input file
    CONST 5
    SYSCALL 0x0010
    POP
    CONST 35
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 1: Read file
    ; ═══════════════════════════════════════════════════════════════
    CONST 6
    SYSCALL 0x0010
    POP

    CONST 35
    SYSCALL 0x0015
    SET_LOCAL 0

    GET_LOCAL 0
    LEN
    SET_LOCAL 1

    GET_LOCAL 1
    TRACE
    CONST 12
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Initialize variables
    ; ═══════════════════════════════════════════════════════════════
    CONST 7
    SYSCALL 0x0010
    POP

    CONST_I64 0
    SET_LOCAL 2      ; pos = 0

    CONST_I64 0
    SET_LOCAL 5      ; function count = 0

    CONST_I64 0
    SET_LOCAL 6      ; token count = 0

    CONST_I64 0
    SET_LOCAL 14     ; if label counter = 0

    CONST_I64 0
    SET_LOCAL 20     ; function index = 0

    CONST_I64 0
    SET_LOCAL 27     ; while label counter = 0

    CONST_I64 0
    SET_LOCAL 28     ; for label counter = 0

    CONST_I64 2
    SET_LOCAL 33     ; local_var_count starts at 2 (after params)

    ; Initialize output with header
    CONST 16
    CONST 17
    ADD
    CONST 35
    ADD
    CONST 18
    ADD
    CONST 19
    ADD
    CONST 34
    ADD
    CONST 20
    ADD
    CONST 21
    ADD
    SET_LOCAL 3

.scan_loop:
    GET_LOCAL 2
    GET_LOCAL 1
    LT
    JUMP_IF_FALSE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Check for 'f' (maybe 'func' or 'for')
    GET_LOCAL 4
    CONST_I64 102
    EQ
    JUMP_IF_TRUE .maybe_func_or_for

    ; Check for @ (annotation) - skip
    GET_LOCAL 4
    CONST_I64 64
    EQ
    JUMP_IF_TRUE .skip_annotation

    JUMP .next_char

.skip_annotation:
    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6

.skip_to_newline:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .next_char

    JUMP .skip_to_newline

.maybe_func_or_for:
    ; Check if we have "func" or "for"
    GET_LOCAL 2
    CONST_I64 4
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_char

    ; Check for 'func' first
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 117      ; 'u'
    EQ
    JUMP_IF_TRUE .check_func

    ; Check for 'for'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 111      ; 'o'
    EQ
    JUMP_IF_TRUE .check_for

    JUMP .next_char

.check_func:
    ; Verify 'func' (f-u-n-c)
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 110      ; 'n'
    NE
    JUMP_IF_TRUE .next_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 3
    ADD
    INDEX
    CONST_I64 99       ; 'c'
    NE
    JUMP_IF_TRUE .next_char

    ; Found 'func'!
    JUMP .found_func

.check_for:
    ; Verify 'for' (f-o-r)
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 114      ; 'r'
    NE
    JUMP_IF_TRUE .next_char

    ; Found 'for' - but only handle it inside function body
    ; For now, skip to next char (for will be handled in parse_body)
    JUMP .next_char

.found_func:
    GET_LOCAL 5
    CONST_I64 1
    ADD
    SET_LOCAL 5

    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6

    ; Skip 'func' and whitespace
    GET_LOCAL 2
    CONST_I64 4
    ADD
    SET_LOCAL 2

.skip_ws_after_func:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_skip_ws

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_skip_ws

    JUMP .record_func_name_start

.inc_skip_ws:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_after_func

.record_func_name_start:
    GET_LOCAL 2
    SET_LOCAL 8

.find_func_name_end:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 40
    EQ
    JUMP_IF_TRUE .extract_func_name

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_func_name_end

.extract_func_name:
    GET_LOCAL 2
    SET_LOCAL 9

    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 9
    SLICE
    SET_LOCAL 10

    ; Print function name
    CONST 15
    SYSCALL 0x0010
    POP
    GET_LOCAL 10
    SYSCALL 0x0010
    POP

    ; Move past '(' and parse params
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    CONST_I64 0
    SET_LOCAL 11     ; param count = 0

    ; Reset local var count for new function (params will be 0 and 1)
    CONST_I64 2
    SET_LOCAL 33

    ; Check if empty params
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .params_done

    ; Parse first param name
    GET_LOCAL 2
    SET_LOCAL 8      ; reuse as param start

.find_first_param_end:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 58     ; ':'
    EQ
    JUMP_IF_TRUE .save_first_param

    GET_LOCAL 4
    CONST_I64 41     ; ')' - no type annotation
    EQ
    JUMP_IF_TRUE .save_first_param_no_type

    GET_LOCAL 4
    CONST_I64 44     ; ',' - no type annotation
    EQ
    JUMP_IF_TRUE .save_first_param_no_type

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_first_param_end

.save_first_param_no_type:
    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 2
    SLICE
    SET_LOCAL 15     ; first param name

    CONST_I64 1
    SET_LOCAL 11
    JUMP .check_more_params_no_skip

.save_first_param:
    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 2
    SLICE
    SET_LOCAL 15     ; first param name

    CONST_I64 1
    SET_LOCAL 11

    ; Skip to comma or close paren
.skip_to_comma:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .params_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .params_done

    GET_LOCAL 4
    CONST_I64 44
    EQ
    JUMP_IF_TRUE .parse_second_param

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_comma

.check_more_params_no_skip:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .params_done

    GET_LOCAL 4
    CONST_I64 44
    EQ
    JUMP_IF_TRUE .parse_second_param

    JUMP .params_done

.parse_second_param:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    ; Skip whitespace
.skip_ws_param2:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_param2

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_param2

    JUMP .record_param2_start

.inc_ws_param2:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_param2

.record_param2_start:
    GET_LOCAL 2
    SET_LOCAL 8

.find_second_param_end:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 58
    EQ
    JUMP_IF_TRUE .save_second_param

    GET_LOCAL 4
    CONST_I64 41     ; ')' - no type
    EQ
    JUMP_IF_TRUE .save_second_param_no_type

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_second_param_end

.save_second_param_no_type:
    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 2
    SLICE
    SET_LOCAL 16     ; second param name

    CONST_I64 2
    SET_LOCAL 11
    JUMP .params_done

.save_second_param:
    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 2
    SLICE
    SET_LOCAL 16     ; second param name

    CONST_I64 2
    SET_LOCAL 11

    ; Skip to close paren
.skip_to_close:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .params_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .params_done

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_close

.params_done:
    ; Print param count
    CONST 37
    SYSCALL 0x0010
    POP
    GET_LOCAL 11
    TRACE
    CONST 38
    SYSCALL 0x0010
    POP

    ; Find opening brace
.find_open_brace:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .found_brace

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_open_brace

.found_brace:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 12     ; body start

    CONST_I64 1
    SET_LOCAL 7      ; brace count

    ; Reset flags for this function
    CONST_I64 0
    SET_LOCAL 19     ; in_if flag
    CONST_I64 0
    SET_LOCAL 21     ; else_seen flag
    CONST_I64 0
    SET_LOCAL 23     ; jump_emitted flag
    CONST_I64 0
    SET_LOCAL 29     ; in_while flag
    CONST_I64 0
    SET_LOCAL 30     ; in_for flag

    ; Generate function header
    GET_LOCAL 3
    CONST 22         ; ".func "
    ADD
    GET_LOCAL 10     ; function name
    ADD
    CONST 23         ; "\n    .arity "
    ADD
    SET_LOCAL 3

    ; Add arity digit
    GET_LOCAL 11
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .arity_0
    GET_LOCAL 11
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .arity_1
    GET_LOCAL 11
    CONST_I64 2
    EQ
    JUMP_IF_TRUE .arity_2
    JUMP .arity_0

.arity_0:
    GET_LOCAL 3
    CONST 32
    ADD
    SET_LOCAL 3
    JUMP .add_func_header

.arity_1:
    GET_LOCAL 3
    CONST 41
    ADD
    SET_LOCAL 3
    JUMP .add_func_header

.arity_2:
    GET_LOCAL 3
    CONST 42
    ADD
    SET_LOCAL 3
    JUMP .add_func_header

.add_func_header:
    GET_LOCAL 3
    CONST 24         ; "\n    .locals 20\n"
    ADD
    CONST 25         ; "    .ai_block \""
    ADD
    GET_LOCAL 10     ; function name
    ADD
    CONST 26         ; "\"\n"
    ADD
    CONST 27         ; "    .ai_intent ...\n\n"
    ADD
    SET_LOCAL 3

    ; Now parse the function body
    GET_LOCAL 12
    SET_LOCAL 2

.parse_body:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .close_func

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Track braces
    GET_LOCAL 4
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .inc_brace_body

    GET_LOCAL 4
    CONST_I64 125
    EQ
    JUMP_IF_TRUE .dec_brace_body

    ; Skip whitespace
    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 4
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 4
    CONST_I64 13
    EQ
    JUMP_IF_TRUE .next_body_char

    ; Check for 'r' (return)
    GET_LOCAL 4
    CONST_I64 114
    EQ
    JUMP_IF_TRUE .check_return

    ; Check for 'i' (if)
    GET_LOCAL 4
    CONST_I64 105
    EQ
    JUMP_IF_TRUE .check_if

    ; Check for 'e' (else)
    GET_LOCAL 4
    CONST_I64 101
    EQ
    JUMP_IF_TRUE .check_else

    ; Check for 'w' (while)
    GET_LOCAL 4
    CONST_I64 119
    EQ
    JUMP_IF_TRUE .check_while

    ; Check for 'f' (for)
    GET_LOCAL 4
    CONST_I64 102
    EQ
    JUMP_IF_TRUE .check_for_in_body

    ; Check for 'l' (let)
    GET_LOCAL 4
    CONST_I64 108
    EQ
    JUMP_IF_TRUE .check_let

    JUMP .next_body_char

.inc_brace_body:
    GET_LOCAL 7
    CONST_I64 1
    ADD
    SET_LOCAL 7
    JUMP .next_body_char

.dec_brace_body:
    GET_LOCAL 7
    CONST_I64 1
    SUB
    SET_LOCAL 7

    GET_LOCAL 7
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .close_func

    ; Check if we're ending an if/else block
    GET_LOCAL 19
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .end_if_block

    ; Check if we're ending a while loop
    GET_LOCAL 29
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .end_while_block

    ; Check if we're ending a for loop
    GET_LOCAL 30
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .end_for_block

    JUMP .next_body_char

.end_if_block:
    GET_LOCAL 21
    CONST_I64 0
    EQ
    JUMP_IF_FALSE .skip_then_jump

    ; Emit JUMP .endif_N and .else_N: label
    GET_LOCAL 3
    CONST 63         ; "    JUMP .endif_"
    ADD
    SET_LOCAL 3

    ; Emit label number
    GET_LOCAL 14
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .emit_if_label_0
    GET_LOCAL 14
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .emit_if_label_1
    JUMP .emit_if_label_0

.emit_if_label_0:
    GET_LOCAL 3
    CONST 32
    ADD
    CONST 39
    ADD
    SET_LOCAL 3
    JUMP .emit_else_label_after_jump

.emit_if_label_1:
    GET_LOCAL 3
    CONST 41
    ADD
    CONST 39
    ADD
    SET_LOCAL 3
    JUMP .emit_else_label_after_jump

.emit_else_label_after_jump:
    ; Emit .else_N:
    GET_LOCAL 3
    CONST 64         ; ".else_"
    ADD
    SET_LOCAL 3

    GET_LOCAL 14
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .emit_else_0
    GET_LOCAL 14
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .emit_else_1
    JUMP .emit_else_0

.emit_else_0:
    GET_LOCAL 3
    CONST 32
    ADD
    CONST 65         ; ":\n"
    ADD
    SET_LOCAL 3
    JUMP .mark_jump_emitted

.emit_else_1:
    GET_LOCAL 3
    CONST 41
    ADD
    CONST 65
    ADD
    SET_LOCAL 3
    JUMP .mark_jump_emitted

.mark_jump_emitted:
    CONST_I64 1
    SET_LOCAL 23
    CONST_I64 1
    SET_LOCAL 21

.skip_then_jump:
    JUMP .next_body_char

; ═══════════════════════════════════════════════════════════════════════════════
; WHILE LOOP HANDLING
; ═══════════════════════════════════════════════════════════════════════════════

.check_while:
    ; Verify "while" keyword (w-h-i-l-e)
    GET_LOCAL 2
    CONST_I64 5
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 104    ; 'h'
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 105    ; 'i'
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 3
    ADD
    INDEX
    CONST_I64 108    ; 'l'
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 4
    ADD
    INDEX
    CONST_I64 101    ; 'e'
    NE
    JUMP_IF_TRUE .next_body_char

    ; Found 'while'!
    CONST 83
    SYSCALL 0x0010
    POP

    GET_LOCAL 2
    CONST_I64 5
    ADD
    SET_LOCAL 2

    ; Emit while label
    GET_LOCAL 3
    CONST 85         ; "    ; while loop\n"
    ADD
    CONST 84         ; ".while_"
    ADD
    SET_LOCAL 3

    ; Emit label number
    GET_LOCAL 27
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .while_label_0
    JUMP .while_label_0  ; For now just use 0

.while_label_0:
    GET_LOCAL 3
    CONST 32         ; "0"
    ADD
    CONST 65         ; ":\n"
    ADD
    SET_LOCAL 3

    ; Skip whitespace
.skip_ws_while:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_while

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_while

    JUMP .parse_while_condition

.inc_ws_while:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_while

.parse_while_condition:
    ; Parse condition like "i < 10"
    ; First operand
    GET_LOCAL 3
    CONST 50         ; "    GET_LOCAL "
    ADD
    SET_LOCAL 3

    ; Find the local index for the variable (simplified: use local 2 for loop var)
    GET_LOCAL 3
    CONST 42         ; "2" (assuming loop var is local 2)
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Find comparison operator
    CONST_I64 0
    SET_LOCAL 18

.find_while_comparison:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .emit_while_jump

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 60     ; '<'
    EQ
    JUMP_IF_TRUE .while_found_lt

    GET_LOCAL 4
    CONST_I64 62     ; '>'
    EQ
    JUMP_IF_TRUE .while_found_gt

    GET_LOCAL 4
    CONST_I64 123    ; '{'
    EQ
    JUMP_IF_TRUE .emit_while_jump

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_while_comparison

.while_found_lt:
    ; Check for '<='
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 61     ; '='
    EQ
    JUMP_IF_TRUE .while_found_le

    CONST_I64 2      ; LT
    SET_LOCAL 18
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .parse_while_second_op

.while_found_le:
    CONST_I64 3      ; LE
    SET_LOCAL 18
    GET_LOCAL 2
    CONST_I64 2
    ADD
    SET_LOCAL 2
    JUMP .parse_while_second_op

.while_found_gt:
    ; Check for '>='
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 61
    EQ
    JUMP_IF_TRUE .while_found_ge

    CONST_I64 1      ; GT
    SET_LOCAL 18
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .parse_while_second_op

.while_found_ge:
    CONST_I64 4      ; GE
    SET_LOCAL 18
    GET_LOCAL 2
    CONST_I64 2
    ADD
    SET_LOCAL 2
    JUMP .parse_while_second_op

.parse_while_second_op:
    ; Skip whitespace
.skip_ws_while_op2:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_while_op2

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_while_op2

    JUMP .check_while_op2_type

.inc_ws_while_op2:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_while_op2

.check_while_op2_type:
    ; Check if digit or var
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 48
    GE
    JUMP_IF_FALSE .while_op2_is_var

    GET_LOCAL 4
    CONST_I64 57
    LE
    JUMP_IF_FALSE .while_op2_is_var

    ; It's a number
    GET_LOCAL 3
    CONST 69         ; "    CONST_I64 "
    ADD
    SET_LOCAL 3

.extract_while_number:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 48
    LT
    JUMP_IF_TRUE .while_number_done

    GET_LOCAL 4
    CONST_I64 57
    GT
    JUMP_IF_TRUE .while_number_done

    ; Append digit
    GET_LOCAL 3
    GET_LOCAL 0
    GET_LOCAL 2
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SLICE
    ADD
    SET_LOCAL 3

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .extract_while_number

.while_number_done:
    GET_LOCAL 3
    CONST 39
    ADD
    SET_LOCAL 3
    JUMP .emit_while_jump

.while_op2_is_var:
    ; Emit GET_LOCAL for second variable
    GET_LOCAL 3
    CONST 50
    ADD
    CONST 43         ; "3" (assuming second var is local 3)
    ADD
    CONST 39
    ADD
    SET_LOCAL 3

    ; Skip variable name
.skip_while_var:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .emit_while_jump

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .emit_while_jump

    GET_LOCAL 4
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .emit_while_jump

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_while_var

.emit_while_jump:
    ; Emit comparison
    GET_LOCAL 18
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .emit_while_gt

    GET_LOCAL 18
    CONST_I64 2
    EQ
    JUMP_IF_TRUE .emit_while_lt

    GET_LOCAL 18
    CONST_I64 3
    EQ
    JUMP_IF_TRUE .emit_while_le

    GET_LOCAL 18
    CONST_I64 4
    EQ
    JUMP_IF_TRUE .emit_while_ge

    JUMP .emit_while_lt  ; Default

.emit_while_gt:
    GET_LOCAL 3
    CONST 56
    ADD
    SET_LOCAL 3
    JUMP .emit_while_jump_false

.emit_while_lt:
    GET_LOCAL 3
    CONST 57
    ADD
    SET_LOCAL 3
    JUMP .emit_while_jump_false

.emit_while_le:
    GET_LOCAL 3
    CONST 58
    ADD
    SET_LOCAL 3
    JUMP .emit_while_jump_false

.emit_while_ge:
    GET_LOCAL 3
    CONST 59
    ADD
    SET_LOCAL 3
    JUMP .emit_while_jump_false

.emit_while_jump_false:
    ; Emit JUMP_IF_FALSE .endwhile_N
    GET_LOCAL 3
    CONST 86         ; "    JUMP_IF_FALSE .endwhile_"
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Set in_while flag
    CONST_I64 1
    SET_LOCAL 29

    ; Skip to opening brace
.skip_to_while_brace:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .enter_while_block

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_while_brace

.enter_while_block:
    GET_LOCAL 7
    CONST_I64 1
    ADD
    SET_LOCAL 7
    JUMP .next_body_char

.end_while_block:
    ; Emit JUMP .while_N to loop back
    GET_LOCAL 3
    CONST 88         ; "    JUMP .while_"
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Emit .endwhile_N:
    GET_LOCAL 3
    CONST 87         ; ".endwhile_"
    ADD
    CONST 32         ; "0"
    ADD
    CONST 65         ; ":\n"
    ADD
    SET_LOCAL 3

    ; Clear in_while flag
    CONST_I64 0
    SET_LOCAL 29

    ; Increment while counter for next loop
    GET_LOCAL 27
    CONST_I64 1
    ADD
    SET_LOCAL 27

    JUMP .next_body_char

; ═══════════════════════════════════════════════════════════════════════════════
; FOR LOOP HANDLING
; ═══════════════════════════════════════════════════════════════════════════════

.check_for_in_body:
    ; Verify "for" keyword (f-o-r)
    GET_LOCAL 2
    CONST_I64 3
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 111    ; 'o'
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 114    ; 'r'
    NE
    JUMP_IF_TRUE .next_body_char

    ; Found 'for'!
    CONST 89
    SYSCALL 0x0010
    POP

    GET_LOCAL 2
    CONST_I64 3
    ADD
    SET_LOCAL 2

    ; Emit for loop comment
    GET_LOCAL 3
    CONST 91         ; "    ; for loop init\n"
    ADD
    SET_LOCAL 3

    ; Skip whitespace to get iterator variable
.skip_ws_for:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_for

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_for

    JUMP .get_for_var

.inc_ws_for:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_for

.get_for_var:
    ; Record variable name start
    GET_LOCAL 2
    SET_LOCAL 8

    ; Find end of variable name (until 'in' keyword)
.find_for_var_end:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32     ; space before 'in'
    EQ
    JUMP_IF_TRUE .check_in_keyword

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_for_var_end

.check_in_keyword:
    ; Skip whitespace and find 'in'
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

.skip_to_in:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 105    ; 'i'
    EQ
    JUMP_IF_TRUE .verify_in

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_in

.verify_in:
    ; Check for 'in'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 110    ; 'n'
    NE
    JUMP_IF_TRUE .skip_to_in

    ; Found 'in', now get range
    GET_LOCAL 2
    CONST_I64 2
    ADD
    SET_LOCAL 2

    ; Skip whitespace
.skip_ws_for_range:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_for_range

    JUMP .parse_for_range

.inc_ws_for_range:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_for_range

.parse_for_range:
    ; Parse range like "0..10"
    ; Get start value
    GET_LOCAL 3
    CONST 69         ; "    CONST_I64 "
    ADD
    SET_LOCAL 3

    ; Extract start number
.extract_for_start:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 48
    LT
    JUMP_IF_TRUE .for_start_done

    GET_LOCAL 4
    CONST_I64 57
    GT
    JUMP_IF_TRUE .for_start_done

    GET_LOCAL 3
    GET_LOCAL 0
    GET_LOCAL 2
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SLICE
    ADD
    SET_LOCAL 3

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .extract_for_start

.for_start_done:
    GET_LOCAL 3
    CONST 39         ; "\n"
    ADD
    CONST 92         ; "    SET_LOCAL "
    ADD
    CONST 42         ; "2" (loop var in local 2)
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Skip the '..' separator
.skip_for_dots:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 46     ; '.'
    EQ
    JUMP_IF_TRUE .inc_for_dot

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .for_dots_done

.inc_for_dot:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_for_dots

.for_dots_done:
    ; Emit for loop label
    GET_LOCAL 3
    CONST 90         ; ".for_"
    ADD
    CONST 32         ; "0"
    ADD
    CONST 65         ; ":\n"
    ADD
    CONST 93         ; "    ; for loop condition\n"
    ADD
    SET_LOCAL 3

    ; Emit condition check: GET_LOCAL 2; CONST_I64 end; LT; JUMP_IF_FALSE
    GET_LOCAL 3
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 42         ; "2"
    ADD
    CONST 39         ; "\n"
    ADD
    CONST 69         ; "    CONST_I64 "
    ADD
    SET_LOCAL 3

    ; Extract end value
.extract_for_end:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 48
    LT
    JUMP_IF_TRUE .for_end_done

    GET_LOCAL 4
    CONST_I64 57
    GT
    JUMP_IF_TRUE .for_end_done

    GET_LOCAL 3
    GET_LOCAL 0
    GET_LOCAL 2
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SLICE
    ADD
    SET_LOCAL 3

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .extract_for_end

.for_end_done:
    GET_LOCAL 3
    CONST 39         ; "\n"
    ADD
    CONST 57         ; "    LT\n"
    ADD
    CONST 124        ; "    JUMP_IF_FALSE .endfor_"
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Set in_for flag
    CONST_I64 1
    SET_LOCAL 30

    ; Skip to opening brace
.skip_to_for_brace:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .enter_for_block

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_for_brace

.enter_for_block:
    GET_LOCAL 7
    CONST_I64 1
    ADD
    SET_LOCAL 7
    JUMP .next_body_char

.end_for_block:
    ; Emit increment: GET_LOCAL 2; CONST_I64 1; ADD; SET_LOCAL 2
    GET_LOCAL 3
    CONST 95         ; "    ; for loop increment\n"
    ADD
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 42         ; "2"
    ADD
    CONST 39         ; "\n"
    ADD
    CONST 96         ; "    CONST_I64 1\n    ADD\n"
    ADD
    CONST 92         ; "    SET_LOCAL "
    ADD
    CONST 42         ; "2"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Emit JUMP .for_0 to loop back
    GET_LOCAL 3
    CONST 123        ; "    JUMP .for_"
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Emit .endfor_0:
    GET_LOCAL 3
    CONST 94         ; ".endfor_"
    ADD
    CONST 32         ; "0"
    ADD
    CONST 65         ; ":\n"
    ADD
    SET_LOCAL 3

    ; Clear in_for flag
    CONST_I64 0
    SET_LOCAL 30

    ; Increment for counter
    GET_LOCAL 28
    CONST_I64 1
    ADD
    SET_LOCAL 28

    JUMP .next_body_char

; ═══════════════════════════════════════════════════════════════════════════════
; LET BINDING HANDLING
; ═══════════════════════════════════════════════════════════════════════════════

.check_let:
    ; Verify "let" keyword (l-e-t)
    GET_LOCAL 2
    CONST_I64 3
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 101    ; 'e'
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 116    ; 't'
    NE
    JUMP_IF_TRUE .next_body_char

    ; Found 'let'!
    GET_LOCAL 2
    CONST_I64 3
    ADD
    SET_LOCAL 2

    ; Skip whitespace
.skip_ws_let:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_let

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_let

    JUMP .get_let_var

.inc_ws_let:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_let

.get_let_var:
    ; Record variable name start
    GET_LOCAL 2
    SET_LOCAL 8

    ; Find end of variable name (until '=' or ':')
.find_let_var_end:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 61     ; '='
    EQ
    JUMP_IF_TRUE .got_let_var

    GET_LOCAL 4
    CONST_I64 58     ; ':'
    EQ
    JUMP_IF_TRUE .skip_let_type

    GET_LOCAL 4
    CONST_I64 32     ; space
    EQ
    JUMP_IF_TRUE .got_let_var

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_let_var_end

.skip_let_type:
    ; Skip type annotation until '='
.find_let_equals:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 61
    EQ
    JUMP_IF_TRUE .got_let_var

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_let_equals

.got_let_var:
    ; Extract variable name
    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 2
    SLICE
    SET_LOCAL 34     ; store var name

    ; Print debug
    CONST 119        ; "  [let detected: "
    SYSCALL 0x0010
    POP
    GET_LOCAL 34
    SYSCALL 0x0010
    POP
    CONST 78         ; "]\n"
    SYSCALL 0x0010
    POP

    ; Skip to value (past '=')
.skip_to_let_value:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 61
    EQ
    JUMP_IF_TRUE .found_let_equals

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_let_value

.found_let_equals:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    ; Skip whitespace
.skip_ws_let_value:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_let_val

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_let_val

    JUMP .parse_let_value

.inc_ws_let_val:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_let_value

.parse_let_value:
    ; Emit comment
    GET_LOCAL 3
    CONST 105        ; "    ; let binding\n"
    ADD
    SET_LOCAL 3

    ; Check if array literal or simple value
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 91     ; '['
    EQ
    JUMP_IF_TRUE .parse_array_literal

    ; Check if it's a number
    GET_LOCAL 4
    CONST_I64 48
    GE
    JUMP_IF_FALSE .let_var_ref

    GET_LOCAL 4
    CONST_I64 57
    LE
    JUMP_IF_FALSE .let_var_ref

    ; It's a number
    GET_LOCAL 3
    CONST 69         ; "    CONST_I64 "
    ADD
    SET_LOCAL 3

.extract_let_number:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 48
    LT
    JUMP_IF_TRUE .let_number_done

    GET_LOCAL 4
    CONST_I64 57
    GT
    JUMP_IF_TRUE .let_number_done

    GET_LOCAL 3
    GET_LOCAL 0
    GET_LOCAL 2
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SLICE
    ADD
    SET_LOCAL 3

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .extract_let_number

.let_number_done:
    GET_LOCAL 3
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_let_set_local

.let_var_ref:
    ; It's a variable reference - emit GET_LOCAL 0 for simplicity
    GET_LOCAL 3
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_let_set_local

.parse_array_literal:
    ; Array literal [1, 2, 3]
    GET_LOCAL 3
    CONST 98         ; "    ; array literal\n"
    ADD
    SET_LOCAL 3

    ; Skip '['
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    CONST_I64 0
    SET_LOCAL 35     ; array size counter

.parse_array_elements:
    ; Skip whitespace
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_array_ws

    GET_LOCAL 4
    CONST_I64 93     ; ']'
    EQ
    JUMP_IF_TRUE .array_done

    GET_LOCAL 4
    CONST_I64 44     ; ','
    EQ
    JUMP_IF_TRUE .inc_array_elem

    ; Must be a number
    GET_LOCAL 4
    CONST_I64 48
    LT
    JUMP_IF_TRUE .inc_array_elem

    GET_LOCAL 4
    CONST_I64 57
    GT
    JUMP_IF_TRUE .inc_array_elem

    ; Emit CONST_I64 for element
    GET_LOCAL 3
    CONST 69
    ADD
    SET_LOCAL 3

.extract_array_num:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 48
    LT
    JUMP_IF_TRUE .array_num_done

    GET_LOCAL 4
    CONST_I64 57
    GT
    JUMP_IF_TRUE .array_num_done

    GET_LOCAL 3
    GET_LOCAL 0
    GET_LOCAL 2
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SLICE
    ADD
    SET_LOCAL 3

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .extract_array_num

.array_num_done:
    GET_LOCAL 3
    CONST 39
    ADD
    SET_LOCAL 3

    GET_LOCAL 35
    CONST_I64 1
    ADD
    SET_LOCAL 35
    JUMP .parse_array_elements

.inc_array_ws:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .parse_array_elements

.inc_array_elem:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .parse_array_elements

.array_done:
    ; Skip ']'
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    ; For arrays, we'll emit SET_LOCAL with current local var count
    ; (simplified - real impl would need array ops)

.emit_let_set_local:
    ; Emit SET_LOCAL N
    GET_LOCAL 3
    CONST 92         ; "    SET_LOCAL "
    ADD
    SET_LOCAL 3

    ; Emit local index digit
    GET_LOCAL 33
    CONST_I64 2
    EQ
    JUMP_IF_TRUE .let_local_2
    GET_LOCAL 33
    CONST_I64 3
    EQ
    JUMP_IF_TRUE .let_local_3
    GET_LOCAL 33
    CONST_I64 4
    EQ
    JUMP_IF_TRUE .let_local_4
    GET_LOCAL 33
    CONST_I64 5
    EQ
    JUMP_IF_TRUE .let_local_5
    JUMP .let_local_2

.let_local_2:
    GET_LOCAL 3
    CONST 42
    ADD
    SET_LOCAL 3
    JUMP .let_local_done

.let_local_3:
    GET_LOCAL 3
    CONST 43
    ADD
    SET_LOCAL 3
    JUMP .let_local_done

.let_local_4:
    GET_LOCAL 3
    CONST 44
    ADD
    SET_LOCAL 3
    JUMP .let_local_done

.let_local_5:
    GET_LOCAL 3
    CONST 45
    ADD
    SET_LOCAL 3
    JUMP .let_local_done

.let_local_done:
    GET_LOCAL 3
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Increment local var counter
    GET_LOCAL 33
    CONST_I64 1
    ADD
    SET_LOCAL 33

    ; Skip to end of line
.skip_let_line:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .parse_body

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .parse_body

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_let_line

; ═══════════════════════════════════════════════════════════════════════════════
; RETURN HANDLING (from v6)
; ═══════════════════════════════════════════════════════════════════════════════

.check_return:
    ; Verify "return" keyword
    GET_LOCAL 2
    CONST_I64 6
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 101
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 116
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 3
    ADD
    INDEX
    CONST_I64 117
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 4
    ADD
    INDEX
    CONST_I64 114
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 5
    ADD
    INDEX
    CONST_I64 110
    NE
    JUMP_IF_TRUE .next_body_char

    ; Found 'return'
    GET_LOCAL 2
    CONST_I64 6
    ADD
    SET_LOCAL 2

    ; Skip whitespace
.skip_ws_return:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_return

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_return

    JUMP .parse_return_expr

.inc_ws_return:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_return

.parse_return_expr:
    ; Simplified: just emit GET_LOCAL 0; RET
    GET_LOCAL 3
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    CONST 55         ; "    RET\n"
    ADD
    SET_LOCAL 3

    ; Skip to end of line
.skip_return_line:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .parse_body

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .parse_body

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_return_line

; ═══════════════════════════════════════════════════════════════════════════════
; IF/ELSE HANDLING (simplified from v6)
; ═══════════════════════════════════════════════════════════════════════════════

.check_if:
    ; Verify "if" keyword
    GET_LOCAL 2
    CONST_I64 2
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 102
    NE
    JUMP_IF_TRUE .next_body_char

    ; Found 'if'
    CONST 76
    SYSCALL 0x0010
    POP

    GET_LOCAL 2
    CONST_I64 2
    ADD
    SET_LOCAL 2

    ; Emit if condition comment
    GET_LOCAL 3
    CONST 67         ; "    ; if condition\n"
    ADD
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Simplified: assume comparison and emit jump
    ; Find '{' and emit JUMP_IF_FALSE
.find_if_brace:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .emit_if_jump

    ; Check for comparison operators
    GET_LOCAL 4
    CONST_I64 62     ; '>'
    EQ
    JUMP_IF_TRUE .if_emit_gt

    GET_LOCAL 4
    CONST_I64 60     ; '<'
    EQ
    JUMP_IF_TRUE .if_emit_lt

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_if_brace

.if_emit_gt:
    ; Skip operator and second operand
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    ; Emit second operand (simplified)
    GET_LOCAL 3
    CONST 50
    ADD
    CONST 41         ; "1"
    ADD
    CONST 39
    ADD
    CONST 56         ; "    GT\n"
    ADD
    SET_LOCAL 3
    JUMP .find_if_brace

.if_emit_lt:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 3
    CONST 50
    ADD
    CONST 41
    ADD
    CONST 39
    ADD
    CONST 57         ; "    LT\n"
    ADD
    SET_LOCAL 3
    JUMP .find_if_brace

.emit_if_jump:
    ; Emit JUMP_IF_FALSE .else_N
    GET_LOCAL 3
    CONST 62         ; "    JUMP_IF_FALSE .else_"
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Set in_if flag
    CONST_I64 1
    SET_LOCAL 19

    ; Enter if block
    GET_LOCAL 7
    CONST_I64 1
    ADD
    SET_LOCAL 7
    JUMP .next_body_char

.check_else:
    ; Verify "else" keyword
    GET_LOCAL 2
    CONST_I64 4
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 108
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 115
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 3
    ADD
    INDEX
    CONST_I64 101
    NE
    JUMP_IF_TRUE .next_body_char

    ; Found 'else'
    CONST_I64 1
    SET_LOCAL 21

    ; Check if jump was already emitted
    GET_LOCAL 23
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .else_label_only

    ; Emit jump and else label
    GET_LOCAL 3
    CONST 63         ; "    JUMP .endif_"
    ADD
    CONST 32
    ADD
    CONST 39
    ADD
    CONST 64         ; ".else_"
    ADD
    CONST 32
    ADD
    CONST 65         ; ":\n"
    ADD
    CONST 68         ; "    ; else branch\n"
    ADD
    SET_LOCAL 3
    JUMP .after_else

.else_label_only:
    GET_LOCAL 3
    CONST 68
    ADD
    SET_LOCAL 3

.after_else:
    CONST_I64 0
    SET_LOCAL 23

    GET_LOCAL 2
    CONST_I64 4
    ADD
    SET_LOCAL 2
    JUMP .parse_body

.next_body_char:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .parse_body

.close_func:
    ; Emit endif if needed
    GET_LOCAL 19
    CONST_I64 0
    NE
    JUMP_IF_TRUE .emit_endif

    JUMP .emit_func_end

.emit_endif:
    ; Emit .else_0: if not already
    GET_LOCAL 21
    CONST_I64 0
    EQ
    JUMP_IF_FALSE .skip_else_endif

    GET_LOCAL 3
    CONST 64
    ADD
    CONST 32
    ADD
    CONST 65
    ADD
    SET_LOCAL 3

.skip_else_endif:
    GET_LOCAL 3
    CONST 66         ; ".endif_"
    ADD
    CONST 32
    ADD
    CONST 65
    ADD
    SET_LOCAL 3

    CONST_I64 0
    SET_LOCAL 19
    CONST_I64 0
    SET_LOCAL 21

.emit_func_end:
    GET_LOCAL 3
    CONST 31         ; ".end\n\n"
    ADD
    SET_LOCAL 3

    GET_LOCAL 20
    CONST_I64 1
    ADD
    SET_LOCAL 20

    JUMP .next_char

.next_char:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .scan_loop

.scan_done:
    ; Print stats
    GET_LOCAL 6
    TRACE
    CONST 13
    SYSCALL 0x0010
    POP

    CONST 8
    SYSCALL 0x0010
    POP

    GET_LOCAL 5
    TRACE
    CONST 14
    SYSCALL 0x0010
    POP

    CONST 9
    SYSCALL 0x0010
    POP

    ; Write output file
    CONST 36
    GET_LOCAL 3
    SYSCALL 0x0016
    POP

    ; Print success
    CONST 10
    SYSCALL 0x0010
    POP

    CONST 11
    SYSCALL 0x0010
    POP

    CONST 36
    SYSCALL 0x0010
    POP

    CONST_I64 0
    RET
.end
