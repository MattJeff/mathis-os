; ════════════════════════════════════════════════════════════════════════════════
; MATHIS COMPILER v6.0 - Full Expression Compiler
; Handles conditionals, function calls, and proper variable references
; ════════════════════════════════════════════════════════════════════════════════

.module "mathisc_v6"
.version "6.0.0"

.constants:
    ; Banner (0-4)
    0: str "╔══════════════════════════════════════════════════════════════╗\n"
    1: str "║       MATHIS COMPILER v6.0 - Full Expression Compiler       ║\n"
    2: str "║      Conditionals, Calls, and Variable References           ║\n"
    3: str "╚══════════════════════════════════════════════════════════════╝\n"
    4: str "\n"

    ; Messages (5-15)
    5: str "Input: "
    6: str "\n[1/4] Reading file...\n"
    7: str "[2/4] Tokenizing...\n"
    8: str "[3/4] Parsing...\n"
    9: str "[4/4] Generating code...\n"
    10: str "\n✓ Compilation successful!\n"
    11: str "Output: "
    12: str " bytes read\n"
    13: str " tokens\n"
    14: str " functions found\n"
    15: str "  func "

    ; Output generation (16-31)
    16: str "; Generated by MATHIS Compiler v6.0\n"
    17: str "; Source: "
    18: str "\n\n"
    19: str ".module \""
    20: str "\"\n"
    21: str ".version \"1.0.0\"\n\n"
    22: str ".func "
    23: str "\n    .arity "
    24: str "\n    .locals 10\n"
    25: str "    .ai_block \""
    26: str "\"\n"
    27: str "    .ai_intent \"Compiled from MATHIS\"\n\n"
    28: str "    ; Function body\n"
    29: str "    GET_LOCAL 0\n    GET_LOCAL 1\n    ADD\n    RET\n"
    30: str "    RET\n"
    31: str ".end\n\n"

    ; Numbers and names (32-40)
    32: str "0"
    33: str "main"
    34: str "compiled"
    35: str "/Users/mathishiguinen/Desktop/Higuinen/llml/examples/hello.mhs"
    36: str "mathisc/output_v6.masm"
    37: str "("
    38: str "): "
    39: str "\n"
    40: str "    ; stub\n    CONST_I64 0\n    RET\n"

    ; Arity and local digits (41-50)
    41: str "1"
    42: str "2"
    43: str "3"
    44: str "4"
    45: str "5"
    46: str "6"
    47: str "7"
    48: str "8"
    49: str "9"
    50: str "    GET_LOCAL "

    ; Operators (51-55)
    51: str "    ADD\n"
    52: str "    SUB\n"
    53: str "    MUL\n"
    54: str "    DIV\n"
    55: str "    RET\n"

    ; Comparisons (56-61)
    56: str "    GT\n"
    57: str "    LT\n"
    58: str "    LE\n"
    59: str "    GE\n"
    60: str "    EQ\n"
    61: str "    NE\n"

    ; Control flow (62-70)
    62: str "    JUMP_IF_FALSE .else_0\n"
    63: str "    JUMP .endif_0\n"
    64: str ".else_0:\n"
    65: str ":\n"
    66: str ".endif_0:\n"
    67: str "    ; if condition\n"
    68: str "    ; else branch\n"
    69: str "    CONST_I64 "
    70: str "    NEG\n"

    ; Call (71-75)
    71: str "    CALL \""
    72: str " "
    73: str "    ; recursive call\n"
    74: str "    ; call "
    75: str " with args\n"

    ; Debug messages (76-80)
    76: str "  [if detected]\n"
    77: str "  [call detected: "
    78: str "]\n"
    79: str "  [var: "
    80: str "  [expr: "

    ; Call format helpers (81-83)
    81: str "\" "
    82: str "\n"

.func main
    .arity 0
    .locals 45
    .ai_block "compiler_main"
    .ai_intent "Compile MATHIS with full expression support"

    ; Locals:
    ; 0 = source code
    ; 1 = source length
    ; 2 = pos
    ; 3 = output string
    ; 4 = temp char
    ; 5 = function count
    ; 6 = token count
    ; 7 = brace count
    ; 8 = function name start
    ; 9 = function name end
    ; 10 = extracted function name
    ; 11 = param count
    ; 12 = body start
    ; 13 = body end
    ; 14 = label counter for if/else
    ; 15 = first param name
    ; 16 = second param name
    ; 17 = temp string
    ; 18 = comparison type (1=GT, 2=LT, 3=LE, 4=GE, 5=EQ, 6=NE)
    ; 19 = in_if_branch flag
    ; 20 = current function index
    ; 21 = else_seen flag (1 if we've emitted an else label)
    ; 22 = var_end position for extracting variable names
    ; 23 = jump_emitted flag (1 if JUMP .endif_0 was already emitted)
    ; 24 = called function name
    ; 25 = call argument count
    ; 26 = temp position for scanning back

    ; ═══════════════════════════════════════════════════════════════
    ; Print banner
    ; ═══════════════════════════════════════════════════════════════
    CONST 0
    SYSCALL 0x0010
    POP
    CONST 1
    SYSCALL 0x0010
    POP
    CONST 2
    SYSCALL 0x0010
    POP
    CONST 3
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; Print input file
    CONST 5
    SYSCALL 0x0010
    POP
    CONST 35
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 1: Read file
    ; ═══════════════════════════════════════════════════════════════
    CONST 6
    SYSCALL 0x0010
    POP

    CONST 35
    SYSCALL 0x0015
    SET_LOCAL 0

    GET_LOCAL 0
    LEN
    SET_LOCAL 1

    GET_LOCAL 1
    TRACE
    CONST 12
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 2: Tokenize & Parse
    ; ═══════════════════════════════════════════════════════════════
    CONST 7
    SYSCALL 0x0010
    POP

    CONST_I64 0
    SET_LOCAL 2      ; pos = 0

    CONST_I64 0
    SET_LOCAL 5      ; function count = 0

    CONST_I64 0
    SET_LOCAL 6      ; token count = 0

    CONST_I64 0
    SET_LOCAL 14     ; label counter = 0

    CONST_I64 0
    SET_LOCAL 20     ; function index = 0

    ; Initialize output with header
    CONST 16
    CONST 17
    ADD
    CONST 35
    ADD
    CONST 18
    ADD
    CONST 19
    ADD
    CONST 34
    ADD
    CONST 20
    ADD
    CONST 21
    ADD
    SET_LOCAL 3

.scan_loop:
    GET_LOCAL 2
    GET_LOCAL 1
    LT
    JUMP_IF_FALSE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Check for 'f' (maybe 'func')
    GET_LOCAL 4
    CONST_I64 102
    EQ
    JUMP_IF_TRUE .maybe_func

    ; Check for @ (annotation) - skip
    GET_LOCAL 4
    CONST_I64 64
    EQ
    JUMP_IF_TRUE .skip_annotation

    JUMP .next_char

.skip_annotation:
    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6

.skip_to_newline:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .next_char

    JUMP .skip_to_newline

.maybe_func:
    ; Check if we have "func" keyword
    GET_LOCAL 2
    CONST_I64 4
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_char

    ; Check 'u'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 117
    NE
    JUMP_IF_TRUE .next_char

    ; Check 'n'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 110
    NE
    JUMP_IF_TRUE .next_char

    ; Check 'c'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 3
    ADD
    INDEX
    CONST_I64 99
    NE
    JUMP_IF_TRUE .next_char

    ; Found 'func'!
    GET_LOCAL 5
    CONST_I64 1
    ADD
    SET_LOCAL 5

    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6

    ; Skip 'func' and whitespace
    GET_LOCAL 2
    CONST_I64 4
    ADD
    SET_LOCAL 2

.skip_ws_after_func:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_skip_ws

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_skip_ws

    JUMP .record_func_name_start

.inc_skip_ws:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_after_func

.record_func_name_start:
    GET_LOCAL 2
    SET_LOCAL 8

.find_func_name_end:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 40
    EQ
    JUMP_IF_TRUE .extract_func_name

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_func_name_end

.extract_func_name:
    GET_LOCAL 2
    SET_LOCAL 9

    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 9
    SLICE
    SET_LOCAL 10

    ; Print function name
    CONST 15
    SYSCALL 0x0010
    POP
    GET_LOCAL 10
    SYSCALL 0x0010
    POP

    ; Move past '(' and parse params
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    CONST_I64 0
    SET_LOCAL 11     ; param count = 0

    ; Check if empty params
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .params_done

    ; Parse first param name
    GET_LOCAL 2
    SET_LOCAL 8      ; reuse as param start

.find_first_param_end:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 58
    EQ
    JUMP_IF_TRUE .save_first_param

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_first_param_end

.save_first_param:
    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 2
    SLICE
    SET_LOCAL 15     ; first param name

    CONST_I64 1
    SET_LOCAL 11

    ; Skip to comma or close paren
.skip_to_comma:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .params_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .params_done

    GET_LOCAL 4
    CONST_I64 44
    EQ
    JUMP_IF_TRUE .parse_second_param

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_comma

.parse_second_param:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    ; Skip whitespace
.skip_ws_param2:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_param2

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_param2

    JUMP .record_param2_start

.inc_ws_param2:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_param2

.record_param2_start:
    GET_LOCAL 2
    SET_LOCAL 8

.find_second_param_end:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 58
    EQ
    JUMP_IF_TRUE .save_second_param

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_second_param_end

.save_second_param:
    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 2
    SLICE
    SET_LOCAL 16     ; second param name

    CONST_I64 2
    SET_LOCAL 11

    ; Skip to close paren
.skip_to_close:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .params_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .params_done

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_close

.params_done:
    ; Print param count
    CONST 37
    SYSCALL 0x0010
    POP
    GET_LOCAL 11
    TRACE
    CONST 38
    SYSCALL 0x0010
    POP

    ; Find opening brace
.find_open_brace:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .found_brace

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_open_brace

.found_brace:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 12     ; body start

    CONST_I64 1
    SET_LOCAL 7      ; brace count

    ; Reset flags for this function
    CONST_I64 0
    SET_LOCAL 19     ; in_if flag
    CONST_I64 0
    SET_LOCAL 21     ; else_seen flag
    CONST_I64 0
    SET_LOCAL 23     ; jump_emitted flag

    ; Generate function header
    GET_LOCAL 3
    CONST 22         ; ".func "
    ADD
    GET_LOCAL 10     ; function name
    ADD
    CONST 23         ; "\n    .arity "
    ADD
    SET_LOCAL 3

    ; Add arity digit
    GET_LOCAL 11
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .arity_0
    GET_LOCAL 11
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .arity_1
    GET_LOCAL 11
    CONST_I64 2
    EQ
    JUMP_IF_TRUE .arity_2
    JUMP .arity_0

.arity_0:
    GET_LOCAL 3
    CONST 32
    ADD
    SET_LOCAL 3
    JUMP .add_func_header

.arity_1:
    GET_LOCAL 3
    CONST 41
    ADD
    SET_LOCAL 3
    JUMP .add_func_header

.arity_2:
    GET_LOCAL 3
    CONST 42
    ADD
    SET_LOCAL 3
    JUMP .add_func_header

.add_func_header:
    GET_LOCAL 3
    CONST 24         ; "\n    .locals 10\n"
    ADD
    CONST 25         ; "    .ai_block \""
    ADD
    GET_LOCAL 10     ; function name
    ADD
    CONST 26         ; "\"\n"
    ADD
    CONST 27         ; "    .ai_intent ...\n\n"
    ADD
    SET_LOCAL 3

    ; Now parse the function body
    GET_LOCAL 12
    SET_LOCAL 2

.parse_body:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .close_func

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Track braces
    GET_LOCAL 4
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .inc_brace_body

    GET_LOCAL 4
    CONST_I64 125
    EQ
    JUMP_IF_TRUE .dec_brace_body

    ; Skip whitespace
    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 4
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 4
    CONST_I64 13
    EQ
    JUMP_IF_TRUE .next_body_char

    ; Check for 'r' (return)
    GET_LOCAL 4
    CONST_I64 114
    EQ
    JUMP_IF_TRUE .check_return

    ; Check for 'i' (if)
    GET_LOCAL 4
    CONST_I64 105
    EQ
    JUMP_IF_TRUE .check_if

    ; Check for 'e' (else)
    GET_LOCAL 4
    CONST_I64 101
    EQ
    JUMP_IF_TRUE .check_else

    JUMP .next_body_char

.inc_brace_body:
    GET_LOCAL 7
    CONST_I64 1
    ADD
    SET_LOCAL 7
    JUMP .next_body_char

.dec_brace_body:
    GET_LOCAL 7
    CONST_I64 1
    SUB
    SET_LOCAL 7

    GET_LOCAL 7
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .close_func

    ; Check if we're ending an if/else block
    GET_LOCAL 19
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .end_if_block

    JUMP .next_body_char

.end_if_block:
    ; End of if block body (closing brace of then-block)
    ; If we haven't seen an else yet (else_seen = 0), we need to emit JUMP to endif
    ; Set jump_emitted flag so that else handler doesn't emit duplicate
    GET_LOCAL 21
    CONST_I64 0
    EQ
    JUMP_IF_FALSE .skip_then_jump

    ; No else seen yet - we're closing the then-block, need to jump over potential else code
    GET_LOCAL 3
    CONST 63         ; "    JUMP .endif_0\n"
    ADD
    SET_LOCAL 3

    ; Set jump_emitted flag (local 23)
    CONST_I64 1
    SET_LOCAL 23

    ; Also emit the else label immediately so subsequent code goes into the right place
    GET_LOCAL 3
    CONST 64         ; ".else_0:\n"
    ADD
    SET_LOCAL 3

    ; Mark that we've seen the else label
    CONST_I64 1
    SET_LOCAL 21

.skip_then_jump:
    JUMP .next_body_char

.check_return:
    ; Verify "return" keyword
    GET_LOCAL 2
    CONST_I64 6
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 101
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 116
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 3
    ADD
    INDEX
    CONST_I64 117
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 4
    ADD
    INDEX
    CONST_I64 114
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 5
    ADD
    INDEX
    CONST_I64 110
    NE
    JUMP_IF_TRUE .next_body_char

    ; Found 'return'
    GET_LOCAL 2
    CONST_I64 6
    ADD
    SET_LOCAL 2

    ; Skip whitespace
.skip_ws_return:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_return

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_return

    JUMP .parse_return_expr

.inc_ws_return:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_return

.parse_return_expr:
    ; Record expression start
    GET_LOCAL 2
    SET_LOCAL 8

    ; Check for unary minus at start
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 45     ; '-'
    EQ
    JUMP_IF_TRUE .found_unary_minus

    ; Find expression end and detect type
    CONST_I64 0
    SET_LOCAL 18     ; operator type (0=single, 1=add, 2=sub, 3=mul, 4=div, 5=unary_neg)

.scan_return_expr:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .compile_return

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .compile_return

    GET_LOCAL 4
    CONST_I64 125
    EQ
    JUMP_IF_TRUE .compile_return

    ; Check for '(' (function call)
    GET_LOCAL 4
    CONST_I64 40
    EQ
    JUMP_IF_TRUE .found_ret_call

    ; Check for operators
    GET_LOCAL 4
    CONST_I64 43
    EQ
    JUMP_IF_TRUE .found_ret_add

    GET_LOCAL 4
    CONST_I64 45
    EQ
    JUMP_IF_TRUE .found_ret_sub

    GET_LOCAL 4
    CONST_I64 42
    EQ
    JUMP_IF_TRUE .found_ret_mul

    GET_LOCAL 4
    CONST_I64 47
    EQ
    JUMP_IF_TRUE .found_ret_div

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .scan_return_expr

.found_ret_add:
    CONST_I64 1
    SET_LOCAL 18
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .scan_return_expr

.found_ret_sub:
    CONST_I64 2
    SET_LOCAL 18
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .scan_return_expr

.found_ret_mul:
    CONST_I64 3
    SET_LOCAL 18
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .scan_return_expr

.found_ret_div:
    CONST_I64 4
    SET_LOCAL 18
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .scan_return_expr

.found_unary_minus:
    ; Unary negation: -n becomes CONST_I64 0; GET_LOCAL 0; SUB
    ; Skip the minus sign
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    ; Emit 0 - n (unary negation as 0 minus n)
    GET_LOCAL 3
    CONST 69         ; "    CONST_I64 "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    CONST 52         ; "    SUB\n"
    ADD
    CONST 55         ; "    RET\n"
    ADD
    SET_LOCAL 3

    ; Skip the variable name and move to next
    JUMP .skip_after_unary

.skip_after_unary:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .parse_body

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .parse_body

    GET_LOCAL 4
    CONST_I64 125
    EQ
    JUMP_IF_TRUE .parse_body

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_after_unary

.found_ret_call:
    ; Function call detected - extract function name
    ; If there's a pending operator (e.g., n * factorial(...)), emit GET_LOCAL 0 first
    GET_LOCAL 18
    CONST_I64 0
    NE
    JUMP_IF_FALSE .no_pending_op

    ; Emit first operand for the binary operation
    GET_LOCAL 3
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

.no_pending_op:
    ; Need to find the start of the function name (identifier before '(')
    ; Scan backwards from current position to find start of identifier
    GET_LOCAL 2
    SET_LOCAL 26     ; save current position (at '(')

.scan_back_for_name:
    ; Check bounds before decrementing
    GET_LOCAL 26
    GET_LOCAL 8
    LE
    JUMP_IF_TRUE .got_name_start

    ; Decrement position
    GET_LOCAL 26
    CONST_I64 1
    SUB
    SET_LOCAL 26

    GET_LOCAL 0
    GET_LOCAL 26
    INDEX
    SET_LOCAL 4

    ; Check if alphanumeric or underscore (part of identifier)
    GET_LOCAL 4
    CONST_I64 97     ; 'a'
    GE
    JUMP_IF_FALSE .check_upper_back
    GET_LOCAL 4
    CONST_I64 122    ; 'z'
    LE
    JUMP_IF_TRUE .scan_back_for_name

.check_upper_back:
    GET_LOCAL 4
    CONST_I64 65     ; 'A'
    GE
    JUMP_IF_FALSE .check_digit_back
    GET_LOCAL 4
    CONST_I64 90     ; 'Z'
    LE
    JUMP_IF_TRUE .scan_back_for_name

.check_digit_back:
    GET_LOCAL 4
    CONST_I64 48     ; '0'
    GE
    JUMP_IF_FALSE .check_under_back
    GET_LOCAL 4
    CONST_I64 57     ; '9'
    LE
    JUMP_IF_TRUE .scan_back_for_name

.check_under_back:
    GET_LOCAL 4
    CONST_I64 95     ; '_'
    EQ
    JUMP_IF_TRUE .scan_back_for_name

    ; Not an identifier char - we found the start (next char is start)
    GET_LOCAL 26
    CONST_I64 1
    ADD
    SET_LOCAL 26

.got_name_start:
    ; Extract function name from local 26 to local 2
    GET_LOCAL 0
    GET_LOCAL 26
    GET_LOCAL 2
    SLICE
    SET_LOCAL 24     ; function name being called

    ; Skip past '('
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    ; Count arguments and skip to closing paren
    ; We'll emit constant values for now (simplified)
    CONST_I64 0
    SET_LOCAL 25     ; arg count

.count_call_args:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .emit_call

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Check for ')' - end of args
    GET_LOCAL 4
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .emit_call

    ; Check for ',' - next arg
    GET_LOCAL 4
    CONST_I64 44
    EQ
    JUMP_IF_TRUE .inc_arg_count

    ; Check for ':' followed by digit - named arg with value
    GET_LOCAL 4
    CONST_I64 58
    EQ
    JUMP_IF_TRUE .parse_arg_value

    ; Check if it's a variable (lowercase letter) - could be arg like 'n' or 'n - 1'
    GET_LOCAL 4
    CONST_I64 97     ; 'a'
    GE
    JUMP_IF_FALSE .skip_call_arg_char
    GET_LOCAL 4
    CONST_I64 122    ; 'z'
    LE
    JUMP_IF_TRUE .parse_var_arg

.skip_call_arg_char:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .count_call_args

.inc_arg_count:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .count_call_args

.parse_var_arg:
    ; Found letter in function arg - could be:
    ; 1. Variable like 'n' in factorial(n - 1)
    ; 2. Named arg like 'a' in add(a:10, b:3)
    ; Need to look ahead to see if there's a ':' after the name

    ; First, skip the variable/param name to see what comes after
    GET_LOCAL 2
    SET_LOCAL 26     ; save position

.peek_after_name:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; If alphanumeric, keep skipping
    GET_LOCAL 4
    CONST_I64 97
    GE
    JUMP_IF_FALSE .check_peek_upper
    GET_LOCAL 4
    CONST_I64 122
    LE
    JUMP_IF_TRUE .inc_peek

.check_peek_upper:
    GET_LOCAL 4
    CONST_I64 65
    GE
    JUMP_IF_FALSE .check_peek_digit
    GET_LOCAL 4
    CONST_I64 90
    LE
    JUMP_IF_TRUE .inc_peek

.check_peek_digit:
    GET_LOCAL 4
    CONST_I64 48
    GE
    JUMP_IF_FALSE .check_peek_under
    GET_LOCAL 4
    CONST_I64 57
    LE
    JUMP_IF_TRUE .inc_peek

.check_peek_under:
    GET_LOCAL 4
    CONST_I64 95
    EQ
    JUMP_IF_TRUE .inc_peek

    ; End of identifier - check if next is ':'
    GET_LOCAL 4
    CONST_I64 58
    EQ
    JUMP_IF_TRUE .is_named_arg

    ; Not a named arg - it's a variable reference
    ; Reset position and emit GET_LOCAL
    GET_LOCAL 26
    SET_LOCAL 2

    GET_LOCAL 3
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    GET_LOCAL 25
    CONST_I64 1
    ADD
    SET_LOCAL 25     ; arg count++

    ; Now continue to skip the variable name
    JUMP .skip_var_name_in_arg

.inc_peek:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .peek_after_name

.is_named_arg:
    ; It's a named arg (a:10 style) - restore position and let normal flow handle ':'
    GET_LOCAL 26
    SET_LOCAL 2
    JUMP .skip_call_arg_char

    ; Skip the variable name
.skip_var_name_in_arg:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; If still alphanumeric, continue
    GET_LOCAL 4
    CONST_I64 97
    GE
    JUMP_IF_FALSE .check_var_arg_op
    GET_LOCAL 4
    CONST_I64 122
    LE
    JUMP_IF_TRUE .skip_var_name_in_arg

.check_var_arg_op:
    ; Check for operator after variable
    ; Skip whitespace first
.skip_ws_var_arg:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_var_arg

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_var_arg

    JUMP .check_op_in_arg

.inc_ws_var_arg:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_var_arg

.check_op_in_arg:
    ; Check for '-' (subtraction)
    GET_LOCAL 4
    CONST_I64 45
    EQ
    JUMP_IF_TRUE .found_sub_in_arg

    ; Check for ')' - end
    GET_LOCAL 4
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .emit_call

    ; Check for ',' - next arg
    GET_LOCAL 4
    CONST_I64 44
    EQ
    JUMP_IF_TRUE .count_call_args

    JUMP .count_call_args

.found_sub_in_arg:
    ; n - X pattern - skip the '-' and whitespace
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

.skip_ws_after_op:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_after_op

    JUMP .emit_sub_arg_value

.inc_ws_after_op:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_after_op

.emit_sub_arg_value:
    ; Emit CONST_I64 for the number and SUB
    GET_LOCAL 3
    CONST 69         ; "    CONST_I64 "
    ADD
    SET_LOCAL 3

    ; Extract the number
.extract_sub_arg_num:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 48
    LT
    JUMP_IF_TRUE .sub_arg_num_done
    GET_LOCAL 4
    CONST_I64 57
    GT
    JUMP_IF_TRUE .sub_arg_num_done

    ; Append digit
    GET_LOCAL 3
    GET_LOCAL 0
    GET_LOCAL 2
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SLICE
    ADD
    SET_LOCAL 3

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .extract_sub_arg_num

.sub_arg_num_done:
    GET_LOCAL 3
    CONST 39         ; "\n"
    ADD
    CONST 52         ; "    SUB\n"
    ADD
    SET_LOCAL 3
    JUMP .count_call_args

.parse_arg_value:
    ; Found ':' - skip it and read the value
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    ; Check if next char is a digit
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; If digit, emit CONST_I64
    GET_LOCAL 4
    CONST_I64 48
    GE
    JUMP_IF_FALSE .skip_to_comma_or_paren
    GET_LOCAL 4
    CONST_I64 57
    LE
    JUMP_IF_FALSE .skip_to_comma_or_paren

    ; Emit CONST_I64 with the digit value
    GET_LOCAL 3
    CONST 69         ; "    CONST_I64 "
    ADD
    SET_LOCAL 3

    ; Extract the number (can be multi-digit)
.extract_call_arg_num:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 48
    LT
    JUMP_IF_TRUE .call_arg_num_done
    GET_LOCAL 4
    CONST_I64 57
    GT
    JUMP_IF_TRUE .call_arg_num_done

    ; Append digit
    GET_LOCAL 3
    GET_LOCAL 0
    GET_LOCAL 2
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SLICE
    ADD
    SET_LOCAL 3

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .extract_call_arg_num

.call_arg_num_done:
    GET_LOCAL 3
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    GET_LOCAL 25
    CONST_I64 1
    ADD
    SET_LOCAL 25

    JUMP .count_call_args

.skip_to_comma_or_paren:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 44
    EQ
    JUMP_IF_TRUE .inc_arg_count
    GET_LOCAL 4
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .emit_call

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_comma_or_paren

.emit_call:
    ; Emit CALL "func_name" arity
    ; Format: CALL "name" N\n
    GET_LOCAL 3
    CONST 71         ; "    CALL \""
    ADD
    GET_LOCAL 24     ; function name
    ADD
    CONST 81         ; "\" " (close quote + space)
    ADD
    SET_LOCAL 3

    ; Emit arity digit
    GET_LOCAL 25
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .call_arity_0
    GET_LOCAL 25
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .call_arity_1
    GET_LOCAL 25
    CONST_I64 2
    EQ
    JUMP_IF_TRUE .call_arity_2
    JUMP .call_arity_0

.call_arity_0:
    GET_LOCAL 3
    CONST 32         ; "0"
    ADD
    CONST 82         ; "\n"
    ADD
    SET_LOCAL 3
    JUMP .after_call_arity

.call_arity_1:
    GET_LOCAL 3
    CONST 41         ; "1"
    ADD
    CONST 82         ; "\n"
    ADD
    SET_LOCAL 3
    JUMP .after_call_arity

.call_arity_2:
    GET_LOCAL 3
    CONST 42         ; "2"
    ADD
    CONST 82         ; "\n"
    ADD
    SET_LOCAL 3
    JUMP .after_call_arity

.after_call_arity:
    ; Skip to end of call expression
.skip_to_call_end:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .call_done
    GET_LOCAL 4
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .call_done

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_call_end

.call_done:
    ; Move past ')'
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    ; Check if there's a pending operator to emit
    GET_LOCAL 18
    CONST_I64 3
    EQ
    JUMP_IF_TRUE .emit_call_mul

    GET_LOCAL 18
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .emit_call_add

    GET_LOCAL 18
    CONST_I64 2
    EQ
    JUMP_IF_TRUE .emit_call_sub

    GET_LOCAL 18
    CONST_I64 4
    EQ
    JUMP_IF_TRUE .emit_call_div

    JUMP .emit_call_ret

.emit_call_mul:
    GET_LOCAL 3
    CONST 53         ; "    MUL\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_call_ret

.emit_call_add:
    GET_LOCAL 3
    CONST 51         ; "    ADD\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_call_ret

.emit_call_sub:
    GET_LOCAL 3
    CONST 52         ; "    SUB\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_call_ret

.emit_call_div:
    GET_LOCAL 3
    CONST 54         ; "    DIV\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_call_ret

.emit_call_ret:
    ; Emit RET
    GET_LOCAL 3
    CONST 55         ; "    RET\n"
    ADD
    SET_LOCAL 3

    JUMP .parse_body

.compile_return:
    ; Generate code based on operator
    GET_LOCAL 18
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .return_single_value

    ; Binary operation - emit both operands then op
    GET_LOCAL 3
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 41         ; "1"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Emit operator
    GET_LOCAL 18
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .emit_add

    GET_LOCAL 18
    CONST_I64 2
    EQ
    JUMP_IF_TRUE .emit_sub

    GET_LOCAL 18
    CONST_I64 3
    EQ
    JUMP_IF_TRUE .emit_mul

    GET_LOCAL 18
    CONST_I64 4
    EQ
    JUMP_IF_TRUE .emit_div

    JUMP .emit_ret

.emit_add:
    GET_LOCAL 3
    CONST 51
    ADD
    SET_LOCAL 3
    JUMP .emit_ret

.emit_sub:
    GET_LOCAL 3
    CONST 52
    ADD
    SET_LOCAL 3
    JUMP .emit_ret

.emit_mul:
    GET_LOCAL 3
    CONST 53
    ADD
    SET_LOCAL 3
    JUMP .emit_ret

.emit_div:
    GET_LOCAL 3
    CONST 54
    ADD
    SET_LOCAL 3
    JUMP .emit_ret

.emit_ret:
    GET_LOCAL 3
    CONST 55         ; "    RET\n"
    ADD
    SET_LOCAL 3
    JUMP .parse_body

.return_single_value:
    ; Single value return - extract variable name and check which param
    ; local 8 has the start of the expression
    ; Find end of identifier
    GET_LOCAL 8
    SET_LOCAL 22     ; use 22 for var_start

.find_var_end:
    GET_LOCAL 0
    GET_LOCAL 22
    INDEX
    SET_LOCAL 4

    ; Check if alphanumeric or underscore
    GET_LOCAL 4
    CONST_I64 97     ; 'a'
    GE
    JUMP_IF_FALSE .check_uppercase
    GET_LOCAL 4
    CONST_I64 122    ; 'z'
    LE
    JUMP_IF_TRUE .inc_var_end

.check_uppercase:
    GET_LOCAL 4
    CONST_I64 65     ; 'A'
    GE
    JUMP_IF_FALSE .check_digit_var
    GET_LOCAL 4
    CONST_I64 90     ; 'Z'
    LE
    JUMP_IF_TRUE .inc_var_end

.check_digit_var:
    GET_LOCAL 4
    CONST_I64 48     ; '0'
    GE
    JUMP_IF_FALSE .check_underscore
    GET_LOCAL 4
    CONST_I64 57     ; '9'
    LE
    JUMP_IF_TRUE .inc_var_end

.check_underscore:
    GET_LOCAL 4
    CONST_I64 95     ; '_'
    EQ
    JUMP_IF_TRUE .inc_var_end

    JUMP .got_var_name

.inc_var_end:
    GET_LOCAL 22
    CONST_I64 1
    ADD
    SET_LOCAL 22
    JUMP .find_var_end

.got_var_name:
    ; Extract variable name
    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 22
    SLICE
    SET_LOCAL 17     ; store in local 17 (temp string)

    ; Compare with second param (local 16)
    ; If matches, use GET_LOCAL 1, otherwise GET_LOCAL 0
    GET_LOCAL 17
    GET_LOCAL 16
    EQ
    JUMP_IF_TRUE .return_second_param

    ; Default to first param
    GET_LOCAL 3
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    CONST 55         ; "    RET\n"
    ADD
    SET_LOCAL 3
    JUMP .parse_body

.return_second_param:
    GET_LOCAL 3
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 41         ; "1"
    ADD
    CONST 39         ; "\n"
    ADD
    CONST 55         ; "    RET\n"
    ADD
    SET_LOCAL 3
    JUMP .parse_body

.check_if:
    ; Verify "if" keyword
    GET_LOCAL 2
    CONST_I64 2
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 102
    NE
    JUMP_IF_TRUE .next_body_char

    ; Found 'if'
    CONST 76
    SYSCALL 0x0010
    POP

    GET_LOCAL 2
    CONST_I64 2
    ADD
    SET_LOCAL 2

    ; Skip whitespace
.skip_ws_if:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_if

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_if

    JUMP .parse_if_condition

.inc_ws_if:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_if

.parse_if_condition:
    ; Parse condition like "a > b" or "n <= 1"
    ; First operand is first param
    GET_LOCAL 3
    CONST 67         ; "    ; if condition\n"
    ADD
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 32         ; "0"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Find comparison operator
    CONST_I64 0
    SET_LOCAL 18

.find_comparison:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .emit_if_jump

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Check for '>'
    GET_LOCAL 4
    CONST_I64 62
    EQ
    JUMP_IF_TRUE .found_gt

    ; Check for '<'
    GET_LOCAL 4
    CONST_I64 60
    EQ
    JUMP_IF_TRUE .found_lt

    ; Check for '{'
    GET_LOCAL 4
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .emit_if_jump

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_comparison

.found_gt:
    ; Check for '>='
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 61
    EQ
    JUMP_IF_TRUE .found_ge

    CONST_I64 1
    SET_LOCAL 18     ; GT
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .parse_second_operand

.found_ge:
    CONST_I64 4
    SET_LOCAL 18     ; GE
    GET_LOCAL 2
    CONST_I64 2
    ADD
    SET_LOCAL 2
    JUMP .parse_second_operand

.found_lt:
    ; Check for '<='
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 61
    EQ
    JUMP_IF_TRUE .found_le

    CONST_I64 2
    SET_LOCAL 18     ; LT
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .parse_second_operand

.found_le:
    CONST_I64 3
    SET_LOCAL 18     ; LE
    GET_LOCAL 2
    CONST_I64 2
    ADD
    SET_LOCAL 2
    JUMP .parse_second_operand

.parse_second_operand:
    ; Skip whitespace
.skip_ws_op2:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_ws_op2

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_ws_op2

    JUMP .check_second_op_type

.inc_ws_op2:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_op2

.check_second_op_type:
    ; Check if digit (literal) or letter (variable)
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Is it a digit?
    GET_LOCAL 4
    CONST_I64 48
    GE
    JUMP_IF_FALSE .second_op_is_var

    GET_LOCAL 4
    CONST_I64 57
    LE
    JUMP_IF_FALSE .second_op_is_var

    ; It's a number literal
    GET_LOCAL 3
    CONST 69         ; "    CONST_I64 "
    ADD
    SET_LOCAL 3

    ; Extract the number
.extract_number:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 48
    LT
    JUMP_IF_TRUE .number_done

    GET_LOCAL 4
    CONST_I64 57
    GT
    JUMP_IF_TRUE .number_done

    ; Append digit
    GET_LOCAL 3
    GET_LOCAL 0
    GET_LOCAL 2
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SLICE
    ADD
    SET_LOCAL 3

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .extract_number

.number_done:
    GET_LOCAL 3
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_if_jump

.second_op_is_var:
    ; It's a variable - emit GET_LOCAL 1 (second param)
    GET_LOCAL 3
    CONST 50         ; "    GET_LOCAL "
    ADD
    CONST 41         ; "1"
    ADD
    CONST 39         ; "\n"
    ADD
    SET_LOCAL 3

    ; Skip to end of identifier
.skip_second_var:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .emit_if_jump

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Check if alphanumeric
    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .emit_if_jump

    GET_LOCAL 4
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .emit_if_jump

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_second_var

.emit_if_jump:
    ; Emit comparison instruction
    GET_LOCAL 18
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .emit_gt

    GET_LOCAL 18
    CONST_I64 2
    EQ
    JUMP_IF_TRUE .emit_lt

    GET_LOCAL 18
    CONST_I64 3
    EQ
    JUMP_IF_TRUE .emit_le

    GET_LOCAL 18
    CONST_I64 4
    EQ
    JUMP_IF_TRUE .emit_ge

    ; Default to GT
    JUMP .emit_gt

.emit_gt:
    GET_LOCAL 3
    CONST 56         ; "    GT\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_jump_false

.emit_lt:
    GET_LOCAL 3
    CONST 57         ; "    LT\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_jump_false

.emit_le:
    GET_LOCAL 3
    CONST 58         ; "    LE\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_jump_false

.emit_ge:
    GET_LOCAL 3
    CONST 59         ; "    GE\n"
    ADD
    SET_LOCAL 3
    JUMP .emit_jump_false

.emit_jump_false:
    ; Emit JUMP_IF_FALSE to else label
    GET_LOCAL 3
    CONST 62         ; "    JUMP_IF_FALSE .else_0\n"
    ADD
    SET_LOCAL 3

    ; Set in_if flag
    CONST_I64 1
    SET_LOCAL 19

    ; Skip to opening brace
.skip_to_if_brace:
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .enter_if_block

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_if_brace

.enter_if_block:
    GET_LOCAL 7
    CONST_I64 1
    ADD
    SET_LOCAL 7
    JUMP .next_body_char

.check_else:
    ; Verify "else" keyword
    GET_LOCAL 2
    CONST_I64 4
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 108
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 115
    NE
    JUMP_IF_TRUE .next_body_char

    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 3
    ADD
    INDEX
    CONST_I64 101
    NE
    JUMP_IF_TRUE .next_body_char

    ; Found 'else'
    ; Mark that we've seen an else (local 21 = 1)
    CONST_I64 1
    SET_LOCAL 21

    ; Check if jump was already emitted by end_if_block (local 23)
    GET_LOCAL 23
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .emit_else_label_only

    ; Emit jump to endif and else label
    GET_LOCAL 3
    CONST 63         ; "    JUMP .endif_0\n"
    ADD
    CONST 64         ; ".else_0:\n"
    ADD
    CONST 68         ; "    ; else branch\n"
    ADD
    SET_LOCAL 3
    JUMP .after_else_emit

.emit_else_label_only:
    ; Jump and else label were already emitted by end_if_block
    ; Just add the comment for clarity
    GET_LOCAL 3
    CONST 68         ; "    ; else branch\n"
    ADD
    SET_LOCAL 3

.after_else_emit:
    ; Reset jump_emitted flag for next if
    CONST_I64 0
    SET_LOCAL 23

    GET_LOCAL 2
    CONST_I64 4
    ADD
    SET_LOCAL 2
    JUMP .parse_body

.next_body_char:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .parse_body

.close_func:
    ; Emit endif label if we had conditionals
    GET_LOCAL 19
    CONST_I64 0
    NE
    JUMP_IF_TRUE .emit_endif_label

    JUMP .emit_func_end

.emit_endif_label:
    ; Check if we already emitted an else label (local 21 = 1 means we saw an else)
    GET_LOCAL 21
    CONST_I64 0
    EQ
    JUMP_IF_FALSE .skip_fallback_else

    ; Add else label pointing to endif (for cases with no else branch)
    GET_LOCAL 3
    CONST 64         ; ".else_0:\n"
    ADD
    SET_LOCAL 3

.skip_fallback_else:
    GET_LOCAL 3
    CONST 66         ; ".endif_0:\n"
    ADD
    SET_LOCAL 3

    ; Reset in_if flag and else_seen flag for next function
    CONST_I64 0
    SET_LOCAL 19
    CONST_I64 0
    SET_LOCAL 21

.emit_func_end:
    GET_LOCAL 3
    CONST 31         ; ".end\n\n"
    ADD
    SET_LOCAL 3

    ; Increment function index
    GET_LOCAL 20
    CONST_I64 1
    ADD
    SET_LOCAL 20

    JUMP .next_char

.next_char:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .scan_loop

.scan_done:
    ; Print stats
    GET_LOCAL 6
    TRACE
    CONST 13
    SYSCALL 0x0010
    POP

    CONST 8
    SYSCALL 0x0010
    POP

    GET_LOCAL 5
    TRACE
    CONST 14
    SYSCALL 0x0010
    POP

    CONST 9
    SYSCALL 0x0010
    POP

    ; Write output file
    CONST 36
    GET_LOCAL 3
    SYSCALL 0x0016
    POP

    ; Print success
    CONST 10
    SYSCALL 0x0010
    POP

    CONST 11
    SYSCALL 0x0010
    POP

    CONST 36
    SYSCALL 0x0010
    POP

    CONST_I64 0
    RET
.end
