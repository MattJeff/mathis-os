; ════════════════════════════════════════════════════════════════════════════════
; MATHIS COMPILER v3.0 - Full Featured Version
; Extracts real function names using SLICE
; ════════════════════════════════════════════════════════════════════════════════

.module "mathisc_v3"
.version "3.0.0"

.constants:
    ; Banner (0-4)
    0: str "╔══════════════════════════════════════════════════════════════╗\n"
    1: str "║       MATHIS COMPILER v3.0 - Full Featured                  ║\n"
    2: str "║      Written in MathisASM - Extracts Real Names             ║\n"
    3: str "╚══════════════════════════════════════════════════════════════╝\n"
    4: str "\n"

    ; Messages (5-15)
    5: str "Input: "
    6: str "\n[1/4] Reading file...\n"
    7: str "[2/4] Tokenizing...\n"
    8: str "[3/4] Parsing...\n"
    9: str "[4/4] Generating code...\n"
    10: str "\n✓ Compilation successful!\n"
    11: str "Output: "
    12: str " bytes read\n"
    13: str " tokens\n"
    14: str " functions found\n"
    15: str "  func "

    ; Output generation (16-31)
    16: str "; Generated by MATHIS Compiler v3.0\n"
    17: str "; Source: "
    18: str "\n\n"
    19: str ".module \""
    20: str "\"\n"
    21: str ".version \"1.0.0\"\n\n"
    22: str ".func "
    23: str "\n    .arity "
    24: str "\n    .locals 10\n"
    25: str "    .ai_block \""
    26: str "\"\n"
    27: str "    .ai_intent \"Compiled from MATHIS\"\n\n"
    28: str "    ; Function body\n"
    29: str "    CONST_I64 0\n"
    30: str "    RET\n"
    31: str ".end\n\n"

    ; Numbers and names (32-34)
    32: str "0"
    33: str "main"
    34: str "compiled"

    ; File paths (35-36)
    35: str "/Users/mathishiguinen/Desktop/Higuinen/llml/examples/hello.mhs"
    36: str "mathisc/output_v3.masm"

.func main
    .arity 0
    .locals 15
    .ai_block "compiler_main"
    .ai_intent "Compile MATHIS with real function name extraction"

    ; Locals:
    ; 0 = source code
    ; 1 = source length
    ; 2 = pos
    ; 3 = output string
    ; 4 = temp char
    ; 5 = function count
    ; 6 = token count
    ; 7 = temp / brace count
    ; 8 = function name start
    ; 9 = function name end
    ; 10 = extracted function name

    ; ═══════════════════════════════════════════════════════════════
    ; Print banner
    ; ═══════════════════════════════════════════════════════════════
    CONST 0
    SYSCALL 0x0010
    POP
    CONST 1
    SYSCALL 0x0010
    POP
    CONST 2
    SYSCALL 0x0010
    POP
    CONST 3
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; Print input file
    CONST 5
    SYSCALL 0x0010
    POP
    CONST 35
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 1: Read file
    ; ═══════════════════════════════════════════════════════════════
    CONST 6
    SYSCALL 0x0010
    POP

    CONST 35
    SYSCALL 0x0015
    SET_LOCAL 0

    GET_LOCAL 0
    LEN
    SET_LOCAL 1

    GET_LOCAL 1
    TRACE
    CONST 12
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 2: Tokenize
    ; ═══════════════════════════════════════════════════════════════
    CONST 7
    SYSCALL 0x0010
    POP

    CONST_I64 0
    SET_LOCAL 2      ; pos = 0

    CONST_I64 0
    SET_LOCAL 5      ; function count = 0

    CONST_I64 0
    SET_LOCAL 6      ; token count = 0

    ; Initialize output with header
    CONST 16
    CONST 17
    ADD
    CONST 35
    ADD
    CONST 18
    ADD
    CONST 19
    ADD
    CONST 34
    ADD
    CONST 20
    ADD
    CONST 21
    ADD
    SET_LOCAL 3

.scan_loop:
    GET_LOCAL 2
    GET_LOCAL 1
    LT
    JUMP_IF_FALSE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Check for 'f' (maybe 'func')
    GET_LOCAL 4
    CONST_I64 102
    EQ
    JUMP_IF_TRUE .maybe_func

    ; Check for @ (annotation)
    GET_LOCAL 4
    CONST_I64 64
    EQ
    JUMP_IF_TRUE .found_annotation

    ; Check for " (string)
    GET_LOCAL 4
    CONST_I64 34
    EQ
    JUMP_IF_TRUE .skip_string

    ; Check for ; (comment)
    GET_LOCAL 4
    CONST_I64 59
    EQ
    JUMP_IF_TRUE .skip_comment

    JUMP .next_char

.found_annotation:
    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6
    JUMP .skip_to_paren_or_newline

.skip_to_paren_or_newline:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .next_char

    GET_LOCAL 4
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .next_char

    JUMP .skip_to_paren_or_newline

.skip_comment:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .next_char

    JUMP .skip_comment

.maybe_func:
    ; Check if we have "func" keyword
    GET_LOCAL 2
    CONST_I64 3
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_char

    ; Check 'u'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 117
    NE
    JUMP_IF_TRUE .next_char

    ; Check 'n'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 110
    NE
    JUMP_IF_TRUE .next_char

    ; Check 'c'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 3
    ADD
    INDEX
    CONST_I64 99
    NE
    JUMP_IF_TRUE .next_char

    ; Found 'func'!
    GET_LOCAL 5
    CONST_I64 1
    ADD
    SET_LOCAL 5

    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6

    ; Skip 'func' and space(s)
    GET_LOCAL 2
    CONST_I64 4
    ADD
    SET_LOCAL 2

    ; Skip whitespace after func
.skip_ws_after_func:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_skip_ws

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_skip_ws

    JUMP .record_func_name_start

.inc_skip_ws:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_after_func

.record_func_name_start:
    ; Record function name start position
    GET_LOCAL 2
    SET_LOCAL 8

    ; Find function name end (at '(' or space)
.find_func_name_end:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 40
    EQ
    JUMP_IF_TRUE .extract_func_name

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .extract_func_name

    GET_LOCAL 4
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .extract_func_name

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_func_name_end

.extract_func_name:
    ; Record end position
    GET_LOCAL 2
    SET_LOCAL 9

    ; Extract function name using SLICE
    ; Stack: source, start, end -> substring
    GET_LOCAL 0      ; source
    GET_LOCAL 8      ; start
    GET_LOCAL 9      ; end
    SLICE
    SET_LOCAL 10     ; extracted name

    ; Print found function
    CONST 15
    SYSCALL 0x0010
    POP
    GET_LOCAL 10
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; Add function to output
    ; .func <name>
    GET_LOCAL 3
    CONST 22
    ADD
    GET_LOCAL 10
    ADD
    CONST 23
    ADD
    CONST 32
    ADD
    CONST 24
    ADD
    CONST 25
    ADD
    GET_LOCAL 10
    ADD
    CONST 26
    ADD
    CONST 27
    ADD
    CONST 28
    ADD
    CONST 29
    ADD
    CONST 30
    ADD
    CONST 31
    ADD
    SET_LOCAL 3

    JUMP .skip_to_brace

.skip_to_brace:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .skip_brace_content

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_to_brace

.skip_brace_content:
    CONST_I64 1
    SET_LOCAL 7

.skip_braces:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .inc_brace

    GET_LOCAL 4
    CONST_I64 125
    EQ
    JUMP_IF_TRUE .dec_brace

    ; Skip strings inside braces
    GET_LOCAL 4
    CONST_I64 34
    EQ
    JUMP_IF_TRUE .skip_string_in_brace

    JUMP .skip_braces

.skip_string_in_brace:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 34
    EQ
    JUMP_IF_TRUE .skip_braces

    ; Check for escape
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 92
    EQ
    JUMP_IF_TRUE .skip_escape_in_brace

    JUMP .skip_string_in_brace

.skip_escape_in_brace:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_string_in_brace

.inc_brace:
    GET_LOCAL 7
    CONST_I64 1
    ADD
    SET_LOCAL 7
    JUMP .skip_braces

.dec_brace:
    GET_LOCAL 7
    CONST_I64 1
    SUB
    SET_LOCAL 7

    GET_LOCAL 7
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .next_char

    JUMP .skip_braces

.skip_string:
    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6

.skip_string_content:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 34
    EQ
    JUMP_IF_TRUE .next_char

    ; Handle escape sequences
    GET_LOCAL 4
    CONST_I64 92
    EQ
    JUMP_IF_TRUE .skip_escape

    JUMP .skip_string_content

.skip_escape:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_string_content

.next_char:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .scan_loop

.scan_done:
    ; Print stats
    GET_LOCAL 6
    TRACE
    CONST 13
    SYSCALL 0x0010
    POP

    CONST 8
    SYSCALL 0x0010
    POP

    GET_LOCAL 5
    TRACE
    CONST 14
    SYSCALL 0x0010
    POP

    CONST 9
    SYSCALL 0x0010
    POP

    ; Write output file
    CONST 36
    GET_LOCAL 3
    SYSCALL 0x0016
    POP

    ; Print success
    CONST 10
    SYSCALL 0x0010
    POP

    CONST 11
    SYSCALL 0x0010
    POP

    CONST 36
    SYSCALL 0x0010
    POP

    CONST_I64 0
    RET
.end
