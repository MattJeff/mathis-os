; ════════════════════════════════════════════════════════════════════════════════
; MATHIS COMPILER (mathisc)
; Written in MathisASM - 100% from scratch, no Rust!
; ════════════════════════════════════════════════════════════════════════════════
;
; This is the main entry point for the MATHIS compiler.
; It compiles .mhs (MATHIS) source code to .masm (MathisASM).
;
; Pipeline:
;   1. Read source file (.mhs)
;   2. Tokenize (lexer)
;   3. Parse (parser) -> AST
;   4. Generate code (codegen) -> .masm
;   5. (External: masm assembler) -> .mbc bytecode
;
; Usage:
;   mathisc compile <input.mhs> -o <output.masm>
;   mathisc check <input.mhs>
;   mathisc tokens <input.mhs>
;   mathisc ast <input.mhs>
;
; ════════════════════════════════════════════════════════════════════════════════

.module "mathisc"
.version "1.0.0"

; ─────────────────────────────────────────────────────────────────────────────────
; CONSTANTS
; ─────────────────────────────────────────────────────────────────────────────────

.constants:
    ; Messages
    0: str "MATHIS Compiler v1.0.0\n"
    1: str "Written in MathisASM - 100% from scratch!\n"
    2: str "═══════════════════════════════════════════════\n"
    3: str "\nUsage: mathisc <command> <file>\n"
    4: str "Commands:\n"
    5: str "  compile <file.mhs>  - Compile to .masm\n"
    6: str "  check <file.mhs>    - Check syntax only\n"
    7: str "  tokens <file.mhs>   - Show tokens\n"
    8: str "  ast <file.mhs>      - Show AST\n"
    9: str "\n"

    ; Status messages
    10: str "Compiling: "
    11: str "Tokenizing...\n"
    12: str "Parsing...\n"
    13: str "Generating code...\n"
    14: str "Done! Output: "
    15: str "\n"
    16: str "Error: "
    17: str "Success: "

    ; Error messages
    18: str "No input file specified\n"
    19: str "Unknown command: "
    20: str "File not found: "
    21: str "Syntax error at line "
    22: str ", column "
    23: str ": "

    ; Commands
    24: str "compile"
    25: str "check"
    26: str "tokens"
    27: str "ast"

    ; File extensions
    28: str ".mhs"
    29: str ".masm"

; ─────────────────────────────────────────────────────────────────────────────────
; MAIN ENTRY POINT
; ─────────────────────────────────────────────────────────────────────────────────

.func main
    .arity 0
    .locals 4
    .ai_block "compiler_main"
    .ai_intent "Main entry point for MATHIS compiler"

    ; Print banner
    CONST 0          ; "MATHIS Compiler v1.0.0\n"
    SYSCALL 0x0010   ; print
    POP

    CONST 1          ; "Written in MathisASM..."
    SYSCALL 0x0010
    POP

    CONST 2          ; separator
    SYSCALL 0x0010
    POP

    ; In a real implementation, we'd get command line args
    ; For now, demonstrate the compilation pipeline

    ; Demo: compile a simple expression
    ; Source: "func add(a: Int, b: Int) -> Int { return a + b }"

    ; Since we can't read files yet (no filesystem syscalls implemented),
    ; we'll demonstrate with a hardcoded test

    ; Print pipeline stages
    CONST 11         ; "Tokenizing...\n"
    SYSCALL 0x0010
    POP

    ; Here we would call tokenize() from lexer module

    CONST 12         ; "Parsing...\n"
    SYSCALL 0x0010
    POP

    ; Here we would call parse() from parser module

    CONST 13         ; "Generating code...\n"
    SYSCALL 0x0010
    POP

    ; Here we would call generate() from codegen module

    CONST 17         ; "Success: "
    SYSCALL 0x0010
    POP

    CONST 14         ; "Done! Output: "
    SYSCALL 0x0010
    POP

    ; Return success
    CONST_I64 0
    RET
.end

; ═══════════════════════════════════════════════════════════════════════════════
; FUNCTION: compile_file
; INPUT: source code string
; OUTPUT: compiled .masm code string
; ═══════════════════════════════════════════════════════════════════════════════

.func compile_file
    .arity 1
    .locals 4
    .ai_block "compile"
    .ai_intent "Compile MATHIS source to MathisASM"

    SET_LOCAL 0      ; source

    ; Step 1: Tokenize
    GET_LOCAL 0
    ; Would call: CALL tokenize 1
    ; For now, create empty token list
    MAKE_LIST 0
    SET_LOCAL 1      ; tokens

    ; Step 2: Parse
    GET_LOCAL 1
    ; Would call: CALL parse 1
    ; For now, create dummy AST
    CONST_I64 1      ; AST_MODULE
    MAKE_LIST 0      ; items
    MAKE_TUPLE 2
    SET_LOCAL 2      ; ast

    ; Step 3: Generate code
    GET_LOCAL 2
    ; Would call: CALL generate 1
    ; For now, return placeholder
    SET_LOCAL 3      ; output

    GET_LOCAL 3
    RET
.end

; ═══════════════════════════════════════════════════════════════════════════════
; FUNCTION: check_syntax
; INPUT: source code string
; OUTPUT: list of errors (empty if valid)
; ═══════════════════════════════════════════════════════════════════════════════

.func check_syntax
    .arity 1
    .locals 2
    .ai_block "syntax_check"
    .ai_intent "Check syntax without generating code"

    SET_LOCAL 0      ; source

    ; Tokenize
    GET_LOCAL 0
    MAKE_LIST 0      ; tokens (placeholder)
    SET_LOCAL 1

    ; Parse (will collect errors)
    GET_LOCAL 1
    ; Would call parse
    POP

    ; Return errors list
    MAKE_LIST 0
    RET
.end

; ═══════════════════════════════════════════════════════════════════════════════
; FUNCTION: show_tokens
; INPUT: source code string
; OUTPUT: none (prints tokens)
; ═══════════════════════════════════════════════════════════════════════════════

.func show_tokens
    .arity 1
    .locals 2
    .ai_block "token_display"
    .ai_intent "Display all tokens from source"

    SET_LOCAL 0      ; source

    ; Tokenize
    GET_LOCAL 0
    ; Would call tokenize
    MAKE_LIST 0
    SET_LOCAL 1      ; tokens

    ; Iterate and print each token
    GET_LOCAL 1
    ITER_START

.token_loop:
    ITER_NEXT
    JUMP_IF_NONE .token_done

    ; Print token
    ; Would format and print
    TRACE            ; debug print
    JUMP .token_loop

.token_done:
    ITER_END
    CONST_NONE
    RET
.end

; ═══════════════════════════════════════════════════════════════════════════════
; FUNCTION: show_ast
; INPUT: source code string
; OUTPUT: none (prints AST)
; ═══════════════════════════════════════════════════════════════════════════════

.func show_ast
    .arity 1
    .locals 2
    .ai_block "ast_display"
    .ai_intent "Display parsed AST from source"

    SET_LOCAL 0      ; source

    ; Tokenize
    GET_LOCAL 0
    MAKE_LIST 0      ; placeholder
    SET_LOCAL 1      ; tokens

    ; Parse
    GET_LOCAL 1
    ; Would call parse
    ; Would then pretty-print AST

    TRACE            ; debug print AST
    CONST_NONE
    RET
.end

; ═══════════════════════════════════════════════════════════════════════════════
; FUNCTION: print_usage
; INPUT: none
; OUTPUT: none
; ═══════════════════════════════════════════════════════════════════════════════

.func print_usage
    .arity 0
    .locals 0
    .ai_block "usage"
    .ai_intent "Print usage information"

    CONST 3          ; Usage header
    SYSCALL 0x0010
    POP

    CONST 4          ; "Commands:\n"
    SYSCALL 0x0010
    POP

    CONST 5          ; compile
    SYSCALL 0x0010
    POP

    CONST 6          ; check
    SYSCALL 0x0010
    POP

    CONST 7          ; tokens
    SYSCALL 0x0010
    POP

    CONST 8          ; ast
    SYSCALL 0x0010
    POP

    CONST 9          ; newline
    SYSCALL 0x0010
    POP

    CONST_NONE
    RET
.end

; ═══════════════════════════════════════════════════════════════════════════════
; FUNCTION: print_error
; INPUT: error message, line, column
; OUTPUT: none
; ═══════════════════════════════════════════════════════════════════════════════

.func print_error
    .arity 3
    .locals 0
    .ai_block "error_print"
    .ai_intent "Print a formatted error message"

    ; col, line, msg on stack

    CONST 16         ; "Error: "
    SYSCALL 0x0010
    POP

    ; Would format: "Error at line X, column Y: message"
    SYSCALL 0x0010   ; print message
    POP

    CONST 15         ; newline
    SYSCALL 0x0010
    POP

    ; Clean up unused args
    POP
    POP

    CONST_NONE
    RET
.end

; ═══════════════════════════════════════════════════════════════════════════════
; FUNCTION: format_token
; INPUT: token tuple
; OUTPUT: formatted string
; ═══════════════════════════════════════════════════════════════════════════════

.func format_token
    .arity 1
    .locals 1
    .ai_block "token_format"
    .ai_intent "Format a token for display"

    SET_LOCAL 0      ; token

    ; Token format: (type, line, col)
    ; Would create string like "IDENT(name) at line 5, col 10"

    ; Placeholder
    GET_LOCAL 0
    RET
.end

; ═══════════════════════════════════════════════════════════════════════════════
; FUNCTION: format_ast_node
; INPUT: AST node, indent level
; OUTPUT: formatted string
; ═══════════════════════════════════════════════════════════════════════════════

.func format_ast_node
    .arity 2
    .locals 2
    .ai_block "ast_format"
    .ai_intent "Format an AST node with indentation"

    SET_LOCAL 1      ; indent
    SET_LOCAL 0      ; node

    ; Would recursively format AST tree with proper indentation
    ; Like:
    ; MODULE
    ;   FUNC add
    ;     PARAMS
    ;       PARAM a: Int
    ;       PARAM b: Int
    ;     BODY
    ;       RETURN
    ;         BINARY +
    ;           IDENT a
    ;           IDENT b

    ; Placeholder
    GET_LOCAL 0
    RET
.end
