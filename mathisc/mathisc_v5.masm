; ════════════════════════════════════════════════════════════════════════════════
; MATHIS COMPILER v5.0 - Expression Compiler
; Parses and compiles function bodies with simple expressions
; ════════════════════════════════════════════════════════════════════════════════

.module "mathisc_v5"
.version "5.0.0"

.constants:
    ; Banner (0-4)
    0: str "╔══════════════════════════════════════════════════════════════╗\n"
    1: str "║       MATHIS COMPILER v5.0 - Expression Compiler            ║\n"
    2: str "║      Written in MathisASM - Compiles Real Code              ║\n"
    3: str "╚══════════════════════════════════════════════════════════════╝\n"
    4: str "\n"

    ; Messages (5-15)
    5: str "Input: "
    6: str "\n[1/4] Reading file...\n"
    7: str "[2/4] Tokenizing...\n"
    8: str "[3/4] Parsing...\n"
    9: str "[4/4] Generating code...\n"
    10: str "\n✓ Compilation successful!\n"
    11: str "Output: "
    12: str " bytes read\n"
    13: str " tokens\n"
    14: str " functions found\n"
    15: str "  func "

    ; Output generation (16-31)
    16: str "; Generated by MATHIS Compiler v5.0\n"
    17: str "; Source: "
    18: str "\n\n"
    19: str ".module \""
    20: str "\"\n"
    21: str ".version \"1.0.0\"\n\n"
    22: str ".func "
    23: str "\n    .arity "
    24: str "\n    .locals 10\n"
    25: str "    .ai_block \""
    26: str "\"\n"
    27: str "    .ai_intent \"Compiled from MATHIS\"\n\n"
    28: str "    ; Function body - binary expression\n"
    29: str "    GET_LOCAL 0\n    GET_LOCAL 1\n    ADD\n    RET\n"
    30: str "    RET\n"
    31: str ".end\n\n"

    ; Numbers and names (32-34)
    32: str "0"
    33: str "main"
    34: str "compiled"

    ; File paths (35-36)
    35: str "/Users/mathishiguinen/Desktop/Higuinen/llml/examples/hello.mhs"
    36: str "mathisc/output_v5.masm"

    ; Extra (37-44)
    37: str "("
    38: str "): "
    39: str " params\n"
    40: str "    ; stub - returns 0\n    CONST_I64 0\n    RET\n"

    ; Arity digits (41-49)
    41: str "1"
    42: str "2"
    43: str "3"
    44: str "4"

    ; Code templates (45-54)
    45: str "    ; return a + b\n    GET_LOCAL 0\n    GET_LOCAL 1\n    ADD\n    RET\n"
    46: str "    ; return a - b\n    GET_LOCAL 0\n    GET_LOCAL 1\n    SUB\n    RET\n"
    47: str "    ; return a * b\n    GET_LOCAL 0\n    GET_LOCAL 1\n    MUL\n    RET\n"
    48: str "    ; return a / b\n    GET_LOCAL 0\n    GET_LOCAL 1\n    DIV\n    RET\n"
    49: str "    ; conditional stub\n    CONST_I64 0\n    RET\n"

.func main
    .arity 0
    .locals 20
    .ai_block "compiler_main"
    .ai_intent "Compile MATHIS with simple expression patterns"

    ; Locals:
    ; 0 = source code
    ; 1 = source length
    ; 2 = pos
    ; 3 = output string
    ; 4 = temp char
    ; 5 = function count
    ; 6 = token count
    ; 7 = brace count
    ; 8 = function name start
    ; 9 = function name end
    ; 10 = extracted function name
    ; 11 = param count
    ; 12 = body start
    ; 13 = body end
    ; 14 = expression type (0=unknown, 1=add, 2=sub, 3=mul, 4=div)

    ; ═══════════════════════════════════════════════════════════════
    ; Print banner
    ; ═══════════════════════════════════════════════════════════════
    CONST 0
    SYSCALL 0x0010
    POP
    CONST 1
    SYSCALL 0x0010
    POP
    CONST 2
    SYSCALL 0x0010
    POP
    CONST 3
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; Print input file
    CONST 5
    SYSCALL 0x0010
    POP
    CONST 35
    SYSCALL 0x0010
    POP
    CONST 4
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 1: Read file
    ; ═══════════════════════════════════════════════════════════════
    CONST 6
    SYSCALL 0x0010
    POP

    CONST 35
    SYSCALL 0x0015
    SET_LOCAL 0

    GET_LOCAL 0
    LEN
    SET_LOCAL 1

    GET_LOCAL 1
    TRACE
    CONST 12
    SYSCALL 0x0010
    POP

    ; ═══════════════════════════════════════════════════════════════
    ; Step 2: Tokenize & Parse
    ; ═══════════════════════════════════════════════════════════════
    CONST 7
    SYSCALL 0x0010
    POP

    CONST_I64 0
    SET_LOCAL 2      ; pos = 0

    CONST_I64 0
    SET_LOCAL 5      ; function count = 0

    CONST_I64 0
    SET_LOCAL 6      ; token count = 0

    ; Initialize output with header
    CONST 16
    CONST 17
    ADD
    CONST 35
    ADD
    CONST 18
    ADD
    CONST 19
    ADD
    CONST 34
    ADD
    CONST 20
    ADD
    CONST 21
    ADD
    SET_LOCAL 3

.scan_loop:
    GET_LOCAL 2
    GET_LOCAL 1
    LT
    JUMP_IF_FALSE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Check for 'f' (maybe 'func')
    GET_LOCAL 4
    CONST_I64 102
    EQ
    JUMP_IF_TRUE .maybe_func

    ; Check for @ (annotation) - skip
    GET_LOCAL 4
    CONST_I64 64
    EQ
    JUMP_IF_TRUE .skip_annotation

    JUMP .next_char

.skip_annotation:
    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6

.skip_to_newline:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 10
    EQ
    JUMP_IF_TRUE .next_char

    JUMP .skip_to_newline

.maybe_func:
    ; Check if we have "func" keyword (need at least 4 more chars)
    GET_LOCAL 2
    CONST_I64 4
    ADD
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .next_char

    ; Check 'u'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 1
    ADD
    INDEX
    CONST_I64 117
    NE
    JUMP_IF_TRUE .next_char

    ; Check 'n'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 2
    ADD
    INDEX
    CONST_I64 110
    NE
    JUMP_IF_TRUE .next_char

    ; Check 'c'
    GET_LOCAL 0
    GET_LOCAL 2
    CONST_I64 3
    ADD
    INDEX
    CONST_I64 99
    NE
    JUMP_IF_TRUE .next_char

    ; Found 'func'!
    GET_LOCAL 5
    CONST_I64 1
    ADD
    SET_LOCAL 5

    GET_LOCAL 6
    CONST_I64 1
    ADD
    SET_LOCAL 6

    ; Skip 'func' and whitespace
    GET_LOCAL 2
    CONST_I64 4
    ADD
    SET_LOCAL 2

.skip_ws_after_func:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 32
    EQ
    JUMP_IF_TRUE .inc_skip_ws

    GET_LOCAL 4
    CONST_I64 9
    EQ
    JUMP_IF_TRUE .inc_skip_ws

    JUMP .record_func_name_start

.inc_skip_ws:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .skip_ws_after_func

.record_func_name_start:
    GET_LOCAL 2
    SET_LOCAL 8

.find_func_name_end:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 40
    EQ
    JUMP_IF_TRUE .extract_func_name

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_func_name_end

.extract_func_name:
    GET_LOCAL 2
    SET_LOCAL 9

    GET_LOCAL 0
    GET_LOCAL 8
    GET_LOCAL 9
    SLICE
    SET_LOCAL 10

    ; Print function name
    CONST 15
    SYSCALL 0x0010
    POP
    GET_LOCAL 10
    SYSCALL 0x0010
    POP

    ; Count params (count commas + 1 if not empty)
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    CONST_I64 0
    SET_LOCAL 11     ; param count

    ; Check if empty params
    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .params_counted

    ; At least one param
    CONST_I64 1
    SET_LOCAL 11

.count_params:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .params_counted

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    GET_LOCAL 4
    CONST_I64 41
    EQ
    JUMP_IF_TRUE .params_counted

    GET_LOCAL 4
    CONST_I64 44
    EQ
    JUMP_IF_TRUE .found_comma

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .count_params

.found_comma:
    GET_LOCAL 11
    CONST_I64 1
    ADD
    SET_LOCAL 11
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .count_params

.params_counted:
    ; Print param count
    CONST 37
    SYSCALL 0x0010
    POP
    GET_LOCAL 11
    TRACE
    CONST 38
    SYSCALL 0x0010
    POP

    ; Find the function body and detect expression type
    ; Skip to opening brace
.find_open_brace:
    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .scan_done

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .found_brace

    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .find_open_brace

.found_brace:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 12     ; body start

    ; Scan body for operator type
    CONST_I64 0
    SET_LOCAL 14     ; expr type = unknown

    CONST_I64 1
    SET_LOCAL 7      ; brace count = 1

.scan_body:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2

    GET_LOCAL 2
    GET_LOCAL 1
    GE
    JUMP_IF_TRUE .body_scanned

    GET_LOCAL 0
    GET_LOCAL 2
    INDEX
    SET_LOCAL 4

    ; Track braces
    GET_LOCAL 4
    CONST_I64 123
    EQ
    JUMP_IF_TRUE .inc_brace

    GET_LOCAL 4
    CONST_I64 125
    EQ
    JUMP_IF_TRUE .dec_brace

    ; Look for operators (only at top level, brace_count = 1)
    GET_LOCAL 7
    CONST_I64 1
    NE
    JUMP_IF_TRUE .scan_body

    ; Check for '+'
    GET_LOCAL 4
    CONST_I64 43
    EQ
    JUMP_IF_TRUE .found_add

    ; Check for '-' (skip negative numbers)
    GET_LOCAL 4
    CONST_I64 45
    EQ
    JUMP_IF_TRUE .maybe_sub

    ; Check for '*'
    GET_LOCAL 4
    CONST_I64 42
    EQ
    JUMP_IF_TRUE .found_mul

    ; Check for '/'
    GET_LOCAL 4
    CONST_I64 47
    EQ
    JUMP_IF_TRUE .found_div

    JUMP .scan_body

.inc_brace:
    GET_LOCAL 7
    CONST_I64 1
    ADD
    SET_LOCAL 7
    JUMP .scan_body

.dec_brace:
    GET_LOCAL 7
    CONST_I64 1
    SUB
    SET_LOCAL 7

    GET_LOCAL 7
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .body_scanned

    JUMP .scan_body

.found_add:
    CONST_I64 1
    SET_LOCAL 14
    JUMP .scan_body

.maybe_sub:
    ; Could be negation - keep scanning but mark as subtraction if not already set
    GET_LOCAL 14
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .set_sub
    JUMP .scan_body

.set_sub:
    CONST_I64 2
    SET_LOCAL 14
    JUMP .scan_body

.found_mul:
    CONST_I64 3
    SET_LOCAL 14
    JUMP .scan_body

.found_div:
    CONST_I64 4
    SET_LOCAL 14
    JUMP .scan_body

.body_scanned:
    GET_LOCAL 2
    SET_LOCAL 13     ; body end

    ; Print expression type detected
    GET_LOCAL 14
    TRACE
    CONST 39
    SYSCALL 0x0010
    POP

    ; Generate function output
    GET_LOCAL 3
    CONST 22         ; ".func "
    ADD
    GET_LOCAL 10     ; function name
    ADD
    CONST 23         ; "\n    .arity "
    ADD
    SET_LOCAL 3

    ; Add arity digit
    GET_LOCAL 11
    CONST_I64 0
    EQ
    JUMP_IF_TRUE .arity_0
    GET_LOCAL 11
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .arity_1
    GET_LOCAL 11
    CONST_I64 2
    EQ
    JUMP_IF_TRUE .arity_2
    GET_LOCAL 11
    CONST_I64 3
    EQ
    JUMP_IF_TRUE .arity_3
    JUMP .arity_0

.arity_0:
    GET_LOCAL 3
    CONST 32
    ADD
    SET_LOCAL 3
    JUMP .add_func_header

.arity_1:
    GET_LOCAL 3
    CONST 41
    ADD
    SET_LOCAL 3
    JUMP .add_func_header

.arity_2:
    GET_LOCAL 3
    CONST 42
    ADD
    SET_LOCAL 3
    JUMP .add_func_header

.arity_3:
    GET_LOCAL 3
    CONST 43
    ADD
    SET_LOCAL 3
    JUMP .add_func_header

.add_func_header:
    GET_LOCAL 3
    CONST 24         ; "\n    .locals 10\n"
    ADD
    CONST 25         ; "    .ai_block \""
    ADD
    GET_LOCAL 10     ; function name
    ADD
    CONST 26         ; "\"\n"
    ADD
    CONST 27         ; "    .ai_intent ...\n\n"
    ADD
    SET_LOCAL 3

    ; Add body based on expression type
    GET_LOCAL 14
    CONST_I64 1
    EQ
    JUMP_IF_TRUE .gen_add

    GET_LOCAL 14
    CONST_I64 2
    EQ
    JUMP_IF_TRUE .gen_sub

    GET_LOCAL 14
    CONST_I64 3
    EQ
    JUMP_IF_TRUE .gen_mul

    GET_LOCAL 14
    CONST_I64 4
    EQ
    JUMP_IF_TRUE .gen_div

    ; Default: stub
    GET_LOCAL 3
    CONST 40
    ADD
    SET_LOCAL 3
    JUMP .close_func

.gen_add:
    GET_LOCAL 3
    CONST 45
    ADD
    SET_LOCAL 3
    JUMP .close_func

.gen_sub:
    GET_LOCAL 3
    CONST 46
    ADD
    SET_LOCAL 3
    JUMP .close_func

.gen_mul:
    GET_LOCAL 3
    CONST 47
    ADD
    SET_LOCAL 3
    JUMP .close_func

.gen_div:
    GET_LOCAL 3
    CONST 48
    ADD
    SET_LOCAL 3
    JUMP .close_func

.close_func:
    GET_LOCAL 3
    CONST 31         ; ".end\n\n"
    ADD
    SET_LOCAL 3

    JUMP .next_char

.next_char:
    GET_LOCAL 2
    CONST_I64 1
    ADD
    SET_LOCAL 2
    JUMP .scan_loop

.scan_done:
    ; Print stats
    GET_LOCAL 6
    TRACE
    CONST 13
    SYSCALL 0x0010
    POP

    CONST 8
    SYSCALL 0x0010
    POP

    GET_LOCAL 5
    TRACE
    CONST 14
    SYSCALL 0x0010
    POP

    CONST 9
    SYSCALL 0x0010
    POP

    ; Write output file
    CONST 36
    GET_LOCAL 3
    SYSCALL 0x0016
    POP

    ; Print success
    CONST 10
    SYSCALL 0x0010
    POP

    CONST 11
    SYSCALL 0x0010
    POP

    CONST 36
    SYSCALL 0x0010
    POP

    CONST_I64 0
    RET
.end
